
> frontend@0.0.0 lint
> eslint . --format json

[{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\eslint.config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\playwright.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\playwright.electron.config.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'devices' is defined but never used.","line":1,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":31},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'path' is defined but never used.","line":2,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":2,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { defineConfig, devices } from '@playwright/test';\nimport * as path from 'path';\n\n/**\n * Playwright Configuration for Electron App Testing\n * Tests the actual Electron desktop application\n */\nexport default defineConfig({\n  testDir: './tests/e2e/electron',\n  timeout: 60000,\n  fullyParallel: false,\n  forbidOnly: !!process.env.CI,\n  retries: 1,\n  workers: 1,\n  \n  reporter: [\n    ['html', { outputFolder: 'playwright-report-electron' }],\n    ['list'],\n  ],\n  \n  use: {\n    trace: 'on-first-retry',\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure',\n  },\n\n  projects: [\n    {\n      name: 'electron',\n      testMatch: '*.electron.spec.ts',\n    },\n  ],\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\App.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Email\\CategoryBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Email\\EmailActions.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Email\\EmailDetailView.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'formatEmailDate' is defined but never used.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'getPriorityIcon' is defined but never used.","line":7,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":42}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Reusable email detail view component - can be used inline or as a page\r\nimport React from 'react';\r\nimport { \r\n  useGetEmailByIdQuery\r\n} from '@/services/emailApi';\r\nimport { CategoryBadge } from '@/components/Email/CategoryBadge';\r\nimport { formatEmailDate, getPriorityIcon } from '@/utils/emailUtils';\r\n\r\n// Helper function to strip email metadata from HTML body\r\nconst stripEmailMetadata = (html: string): string => {\r\n  if (!html) return '';\r\n  \r\n  // Remove the metadata section that Outlook adds (From:/To:/Sent:/Subject: lines)\r\n  // These appear at the start of the HTML body before the actual content\r\n  let cleaned = html;\r\n  \r\n  // Pattern to match the metadata block (From:, Sent:, To:, Subject: lines)\r\n  // This typically appears before the main email content\r\n  const metadataPattern = /(^|<body[^>]*>)([\\s\\S]*?)(From:|FYI From:|Sent:|To:|Subject:|Cc:)([\\s\\S]*?)(Hello|Hi|Dear|<p|<div|$)/i;\r\n  \r\n  const match = cleaned.match(metadataPattern);\r\n  if (match && match.index !== undefined) {\r\n    // Find where \"Hello\", \"Hi\", \"Dear\", or actual content starts\r\n    const contentStart = match[0].lastIndexOf(match[5]);\r\n    if (contentStart > 0) {\r\n      const beforeMetadata = match[1] || '';\r\n      const afterMetadata = match[0].substring(contentStart);\r\n      cleaned = beforeMetadata + afterMetadata + cleaned.substring(match.index + match[0].length);\r\n    }\r\n  }\r\n  \r\n  return cleaned;\r\n};\r\n\r\n// Helper function to sanitize and prepare HTML email content for display\r\nconst prepareEmailHTML = (content: string): string => {\r\n  if (!content) return '';\r\n  \r\n  // Check if content is HTML\r\n  const isHTML = /<[a-z][\\s\\S]*>/i.test(content);\r\n  \r\n  if (isHTML) {\r\n    // For HTML emails, strip metadata headers and return clean content\r\n    return stripEmailMetadata(content);\r\n  } else {\r\n    // For plain text emails, convert to basic HTML\r\n    let formatted = content;\r\n    \r\n    // Convert URLs to links\r\n    const urlRegex = /(https?:\\/\\/[^\\s<]+[^<.,:;\"')\\]\\s])/g;\r\n    formatted = formatted.replace(urlRegex, (url) => {\r\n      return `<a href=\"${url}\" target=\"_blank\" rel=\"noopener noreferrer\">${url}</a>`;\r\n    });\r\n    \r\n    // Convert line breaks to <br> tags\r\n    formatted = formatted.replace(/\\n/g, '<br>');\r\n    formatted = formatted.replace(/(<br>){2,}/g, '</p><p>');\r\n    formatted = `<p>${formatted}</p>`;\r\n    \r\n    return formatted;\r\n  }\r\n};\r\n\r\ninterface EmailDetailViewProps {\r\n  emailId: string;\r\n  onClose?: () => void;\r\n}\r\n\r\nexport const EmailDetailView: React.FC<EmailDetailViewProps> = ({ \r\n  emailId, \r\n  onClose\r\n}) => {\r\n  const { data: email, isLoading, error } = useGetEmailByIdQuery(emailId);\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"email-detail-loading\">\r\n        <div className=\"loading-spinner\" />\r\n        <div>Loading email...</div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (error || !email) {\r\n    return (\r\n      <div className=\"email-detail-error\">\r\n        <h2 className=\"email-detail-error__title\">Error Loading Email</h2>\r\n        <p className=\"email-detail-error__message\">{error ? 'Failed to load email' : 'Email not found'}</p>\r\n        {onClose && (\r\n          <button onClick={onClose} className=\"synthwave-button\">\r\n            Close\r\n          </button>\r\n        )}\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"email-detail-container\">\r\n      {/* AI Summary - prominent display at top */}\r\n      {email.one_line_summary && (\r\n        <div className=\"email-detail-ai-summary\">\r\n          <div className=\"email-detail-ai-summary__label\">\r\n            <span className=\"email-detail-ai-summary__icon\">≡ƒÆí</span> AI Summary\r\n          </div>\r\n          <div className=\"email-detail-ai-summary__text\">\r\n            {email.one_line_summary}\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {/* AI Category Badge */}\r\n      {email.ai_category && (\r\n        <div className=\"email-detail-category-wrapper\">\r\n          <CategoryBadge \r\n            category={email.ai_category} \r\n            confidence={email.ai_confidence}\r\n          />\r\n        </div>\r\n      )}\r\n\r\n      {/* Email Body - renders HTML content directly */}\r\n      <div\r\n        className=\"email-detail-content\"\r\n        dangerouslySetInnerHTML={{ __html: prepareEmailHTML(email.body || '') }}\r\n      />\r\n    </div>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Email\\EmailItem.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Email\\ProgressBar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Task\\DeadlineIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Task\\ProgressTracker.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Task\\SimpleTaskList.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":60,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2124,2127],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2124,2127],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":74,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2478,2481],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2478,2481],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":89,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":15}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Simple Task List - Just tasks with checkboxes - ADHD-Friendly Edition\r\nimport React, { useState } from 'react';\r\nimport { useUpdateTaskMutation, useDeleteTaskMutation } from '@/services/taskApi';\r\nimport type { Task } from '@/types/task';\r\nimport { TaskCelebration } from './TaskCelebration';\r\n\r\ninterface SimpleTaskListProps {\r\n  tasks: Task[];\r\n  onRefresh?: () => void;\r\n}\r\n\r\nconst ENCOURAGEMENTS = [\r\n  \"≡ƒÄë Amazing work!\",\r\n  \"Γ¡É You're crushing it!\",\r\n  \"≡ƒöÑ On fire today!\",\r\n  \"≡ƒÆ¬ Keep it up!\",\r\n  \"≡ƒÜÇ Unstoppable!\",\r\n  \"Γ£¿ You're doing great!\",\r\n  \"≡ƒÄ» Nailed it!\",\r\n  \"≡ƒæÅ Fantastic!\",\r\n  \"≡ƒîƒ Brilliant!\"\r\n];\r\n\r\nexport const SimpleTaskList: React.FC<SimpleTaskListProps> = ({ tasks, onRefresh }) => {\r\n  const [updateTask] = useUpdateTaskMutation();\r\n  const [deleteTask] = useDeleteTaskMutation();\r\n  const [showCelebration, setShowCelebration] = useState(false);\r\n  const [recentlyCompleted, setRecentlyCompleted] = useState<Set<string>>(new Set());\r\n\r\n  // Separate completed and active tasks\r\n  const [showCompleted, setShowCompleted] = useState(false);\r\n  const completedTasks = tasks.filter(t => t.status === 'done');\r\n  const activeTasks = tasks.filter(t => t.status !== 'done');\r\n  const completedCount = completedTasks.length;\r\n  const totalCount = tasks.length;\r\n  const completionPercentage = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;\r\n\r\n  const handleToggleComplete = async (task: Task) => {\r\n    try {\r\n      const newStatus = task.status === 'done' ? 'todo' : 'done';\r\n      \r\n      // Play completion sound if marking as done\r\n      if (newStatus === 'done') {\r\n        playCompletionSound();\r\n        setShowCelebration(true);\r\n        setRecentlyCompleted(prev => new Set([...prev, task.id]));\r\n        \r\n        // Remove from recently completed after animation\r\n        setTimeout(() => {\r\n          setRecentlyCompleted(prev => {\r\n            const next = new Set(prev);\r\n            next.delete(task.id);\r\n            return next;\r\n          });\r\n        }, 2000);\r\n      }\r\n      \r\n      await updateTask({\r\n        id: task.id,\r\n        data: { status: newStatus as any }\r\n      }).unwrap();\r\n      \r\n      if (onRefresh) {\r\n        onRefresh();\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to update task:', error);\r\n    }\r\n  };\r\n\r\n  const playCompletionSound = () => {\r\n    // Create a simple beep sound using Web Audio API\r\n    try {\r\n      const audioContext = new (window.AudioContext || (window as any).webkitAudioContext)();\r\n      const oscillator = audioContext.createOscillator();\r\n      const gainNode = audioContext.createGain();\r\n      \r\n      oscillator.connect(gainNode);\r\n      gainNode.connect(audioContext.destination);\r\n      \r\n      oscillator.frequency.value = 800;\r\n      oscillator.type = 'sine';\r\n      \r\n      gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);\r\n      gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);\r\n      \r\n      oscillator.start(audioContext.currentTime);\r\n      oscillator.stop(audioContext.currentTime + 0.1);\r\n    } catch (e) {\r\n      // Silent fail if audio not supported\r\n      console.debug('Audio not available');\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (taskId: string) => {\r\n    if (!window.confirm('Delete this task?')) {\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      await deleteTask(taskId).unwrap();\r\n      if (onRefresh) {\r\n        onRefresh();\r\n      }\r\n    } catch (error) {\r\n      console.error('Failed to delete task:', error);\r\n    }\r\n  };\r\n\r\n  const getPriorityEmoji = (priority: string) => {\r\n    switch (priority) {\r\n      case 'high':\r\n      case 'urgent':\r\n        return '≡ƒö┤';\r\n      case 'medium':\r\n        return '≡ƒƒí';\r\n      case 'low':\r\n        return '≡ƒƒó';\r\n      default:\r\n        return 'ΓÜ¬';\r\n    }\r\n  };\r\n\r\n  const getCategoryIcon = (category?: string) => {\r\n    if (!category) return '≡ƒôï';\r\n    \r\n    switch (category.toLowerCase()) {\r\n      case 'required_action':\r\n      case 'required_personal_action':\r\n        return 'ΓÜí';\r\n      case 'team_action':\r\n        return '≡ƒæÑ';\r\n      case 'optional_action':\r\n        return '≡ƒÆí';\r\n      case 'job_listing':\r\n        return '≡ƒÆ╝';\r\n      case 'optional_event':\r\n        return '≡ƒÄ¬';\r\n      case 'newsletter':\r\n        return '≡ƒô░';\r\n      case 'fyi':\r\n        return '≡ƒôï';\r\n      default:\r\n        return '≡ƒô¥';\r\n    }\r\n  };\r\n\r\n  const formatDate = (dateString?: string) => {\r\n    if (!dateString) return null;\r\n    const date = new Date(dateString);\r\n    const now = new Date();\r\n    const diffDays = Math.floor((date.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));\r\n    \r\n    if (diffDays < 0) return <span className=\"simple-task-due-date overdue\">Overdue</span>;\r\n    if (diffDays === 0) return <span className=\"simple-task-due-date today\">Today</span>;\r\n    if (diffDays === 1) return <span className=\"simple-task-due-date tomorrow\">Tomorrow</span>;\r\n    if (diffDays <= 7) return <span className=\"simple-task-due-date upcoming\">In {diffDays} days</span>;\r\n    \r\n    return <span className=\"simple-task-due-date upcoming\">{date.toLocaleDateString()}</span>;\r\n  };\r\n\r\n  const extractLinks = (task: Task): string[] => {\r\n    const links: string[] = [];\r\n    \r\n    // Check metadata\r\n    if (task.metadata?.links && Array.isArray(task.metadata.links)) {\r\n      links.push(...task.metadata.links);\r\n    }\r\n    \r\n    // Extract from description\r\n    if (task.description) {\r\n      const urlRegex = /(https?:\\/\\/[^\\s]+)/g;\r\n      const matches = task.description.match(urlRegex);\r\n      if (matches) {\r\n        links.push(...matches);\r\n      }\r\n    }\r\n    \r\n    return [...new Set(links)]; // Remove duplicates\r\n  };\r\n\r\n  const groupedTasks = {\r\n    'Required Personal Actions': activeTasks.filter(t => t.category?.includes('required') && !t.category?.includes('team') && t.category !== 'newsletter' && t.category !== 'fyi'),\r\n    'Team Actions': activeTasks.filter(t => t.category?.includes('team') && t.category !== 'newsletter' && t.category !== 'fyi'),\r\n    'Optional Actions': activeTasks.filter(t => t.category?.includes('optional') && !t.category?.includes('event') && !t.category?.includes('job') && t.category !== 'newsletter' && t.category !== 'fyi'),\r\n    'Job Listings': activeTasks.filter(t => t.category?.includes('job') && t.category !== 'newsletter' && t.category !== 'fyi'),\r\n    'Events': activeTasks.filter(t => t.category?.includes('event') && t.category !== 'newsletter' && t.category !== 'fyi'),\r\n    'Other': activeTasks.filter(t => !t.category || (!t.category.includes('required') && !t.category.includes('team') && !t.category.includes('optional') && !t.category.includes('job') && !t.category.includes('event') && t.category !== 'newsletter' && t.category !== 'fyi'))\r\n  };\r\n\r\n  const renderTaskGroup = (groupName: string, groupTasks: Task[]) => {\r\n    if (groupTasks.length === 0) return null;\r\n\r\n    const completedCount = groupTasks.filter(t => t.status === 'done').length;\r\n    const totalCount = groupTasks.length;\r\n\r\n    return (\r\n      <div key={groupName} className=\"task-group\">\r\n        <h2 className=\"task-group-header\">\r\n          {groupName} ({completedCount}/{totalCount} complete)\r\n        </h2>\r\n        <div className=\"task-group-items\">\r\n          {groupTasks.map(task => {\r\n            const links = extractLinks(task);\r\n            const isDone = task.status === 'done';\r\n            \r\n            const taskItemClasses = [\r\n              'simple-task-item',\r\n              isDone && !recentlyCompleted.has(task.id) ? 'completed' : '',\r\n              recentlyCompleted.has(task.id) ? 'recently-completed' : ''\r\n            ].filter(Boolean).join(' ');\r\n\r\n            return (\r\n              <div key={task.id} className={taskItemClasses}>\r\n                {/* Checkbox */}\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={isDone}\r\n                  onChange={() => handleToggleComplete(task)}\r\n                  className=\"simple-task-checkbox\"\r\n                />\r\n                \r\n                {/* Task Content */}\r\n                <div className=\"simple-task-content\">\r\n                  {/* Title Row */}\r\n                  <div className=\"simple-task-title-row\">\r\n                    <span className=\"simple-task-icon\">{getCategoryIcon(task.category)}</span>\r\n                    <span className=\"simple-task-icon\">{getPriorityEmoji(task.priority)}</span>\r\n                    <span className={`simple-task-title ${isDone ? 'completed' : ''}`}>\r\n                      {task.title}\r\n                    </span>\r\n                    {task.due_date && (\r\n                      <>{formatDate(task.due_date)}</>\r\n                    )}\r\n                  </div>\r\n\r\n                  {/* Description - Show AI summary or shortened version */}\r\n                  {task.description && (\r\n                    <div className=\"simple-task-description\">\r\n                      {/* Show only first paragraph or first 200 chars for readability */}\r\n                      {(() => {\r\n                        const firstParagraph = task.description.split('\\n\\n')[0];\r\n                        const shortDescription = firstParagraph.length > 200 \r\n                          ? firstParagraph.substring(0, 200) + '...'\r\n                          : firstParagraph;\r\n                        return shortDescription;\r\n                      })()}\r\n                    </div>\r\n                  )}\r\n\r\n                  {/* Links - Prominently Displayed */}\r\n                  {links.length > 0 && (\r\n                    <div className=\"simple-task-links\">\r\n                      <div className=\"simple-task-links-header\">\r\n                        ≡ƒöù Important Links:\r\n                      </div>\r\n                      {links.map((link, idx) => (\r\n                        <div key={idx} className=\"simple-task-link\">\r\n                          <a\r\n                            href={link}\r\n                            target=\"_blank\"\r\n                            rel=\"noopener noreferrer\"\r\n                          >\r\n                            {link}\r\n                          </a>\r\n                        </div>\r\n                      ))}\r\n                    </div>\r\n                  )}\r\n\r\n                  {/* Tags */}\r\n                  {task.tags && task.tags.length > 0 && (\r\n                    <div className=\"simple-task-tags\">\r\n                      {task.tags.map((tag, idx) => (\r\n                        <span key={idx} className=\"simple-task-tag\">\r\n                          {tag}\r\n                        </span>\r\n                      ))}\r\n                    </div>\r\n                  )}\r\n                </div>\r\n\r\n                {/* Delete Button */}\r\n                <button\r\n                  onClick={() => handleDelete(task.id)}\r\n                  className=\"simple-task-delete-btn\"\r\n                  title=\"Delete task\"\r\n                >\r\n                  ≡ƒùæ∩╕Å\r\n                </button>\r\n              </div>\r\n            );\r\n          })}\r\n        </div>\r\n      </div>\r\n    );\r\n  };\r\n\r\n  const getEncouragementMessage = () => {\r\n    if (completionPercentage === 100 && totalCount > 0) {\r\n      return \"≡ƒÅå All done! You're a superstar!\";\r\n    }\r\n    if (completionPercentage >= 75) {\r\n      return ENCOURAGEMENTS[Math.floor(Math.random() * ENCOURAGEMENTS.length)];\r\n    }\r\n    if (completionPercentage >= 50) {\r\n      return \"≡ƒÆ¬ You're making great progress!\";\r\n    }\r\n    if (completionPercentage >= 25) {\r\n      return \"≡ƒîƒ Keep going, you've got this!\";\r\n    }\r\n    return \"≡ƒÜÇ Let's get started!\";\r\n  };\r\n\r\n  return (\r\n    <div className=\"simple-task-list\">\r\n      {/* Celebration Animation */}\r\n      {showCelebration && (\r\n        <TaskCelebration onComplete={() => setShowCelebration(false)} />\r\n      )}\r\n\r\n      {/* Progress and Motivation Section */}\r\n      {tasks.length > 0 && (\r\n        <div className=\"simple-task-progress-section\">\r\n          <div className=\"simple-task-progress-header\">\r\n            <div className=\"simple-task-encouragement\">\r\n              {getEncouragementMessage()}\r\n            </div>\r\n            <div className=\"simple-task-count\">\r\n              {completedCount}/{totalCount}\r\n            </div>\r\n          </div>\r\n          \r\n          {/* Progress Bar */}\r\n          <div className=\"simple-task-progress-bar-container\">\r\n            <div className=\"simple-task-progress-bar\" style={{ width: `${completionPercentage}%` }}>\r\n              {completionPercentage > 10 && `${completionPercentage}%`}\r\n            </div>\r\n            {completionPercentage <= 10 && (\r\n              <div className=\"simple-task-progress-text-overlay\">\r\n                {completionPercentage}%\r\n              </div>\r\n            )}\r\n          </div>\r\n        </div>\r\n      )}\r\n\r\n      {Object.entries(groupedTasks).map(([groupName, groupTasks]) => \r\n        renderTaskGroup(groupName, groupTasks)\r\n      )}\r\n      \r\n      {/* Completed Tasks - Collapsed Section */}\r\n      {completedTasks.length > 0 && (\r\n        <div className=\"completed-tasks-section\">\r\n          <button\r\n            onClick={() => setShowCompleted(!showCompleted)}\r\n            className=\"completed-tasks-toggle\"\r\n          >\r\n            {showCompleted ? 'Γû╝' : 'Γû╢'} Completed Tasks ({completedTasks.length})\r\n          </button>\r\n          {showCompleted && (\r\n            <div className=\"completed-tasks-list\">\r\n              {completedTasks.map(task => {\r\n                return (\r\n                  <div key={task.id} className=\"simple-task-item completed\">\r\n                    <input\r\n                      type=\"checkbox\"\r\n                      checked={true}\r\n                      onChange={() => handleToggleComplete(task)}\r\n                      className=\"simple-task-checkbox\"\r\n                    />\r\n                    <div className=\"simple-task-content\">\r\n                      <div className=\"simple-task-title-row\">\r\n                        <span className=\"simple-task-icon\">{getCategoryIcon(task.category)}</span>\r\n                        <span className=\"simple-task-title completed\">\r\n                          {task.title}\r\n                        </span>\r\n                      </div>\r\n                    </div>\r\n                    <button\r\n                      onClick={() => handleDelete(task.id)}\r\n                      className=\"simple-task-delete-btn\"\r\n                      title=\"Delete task\"\r\n                    >\r\n                      ≡ƒùæ∩╕Å\r\n                    </button>\r\n                  </div>\r\n                );\r\n              })}\r\n            </div>\r\n          )}\r\n        </div>\r\n      )}\r\n      \r\n      {tasks.length === 0 && (\r\n        <div className=\"simple-task-empty-state\">\r\n          <div className=\"simple-task-empty-icon\">≡ƒôï</div>\r\n          <div className=\"simple-task-empty-title\">No tasks yet</div>\r\n          <div className=\"simple-task-empty-description\">\r\n            Tasks will appear here after you extract them from emails\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Task\\TaskCelebration.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Task\\TaskFilters.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":14,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[505,508],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[505,508],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":24,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[733,736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[733,736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":25,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[770,773],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[770,773],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\r\nimport type { TaskFilter } from '@/types/task';\r\n\r\ninterface TaskFiltersProps {\r\n  filters: TaskFilter;\r\n  onChange: (filters: TaskFilter) => void;\r\n  onReset: () => void;\r\n}\r\n\r\nexport const TaskFilters: React.FC<TaskFiltersProps> = ({ filters, onChange, onReset }) => {\r\n  const [isExpanded, setIsExpanded] = useState(false);\r\n  const [searchInput, setSearchInput] = useState(filters.search || '');\r\n\r\n  const handleFilterChange = (key: keyof TaskFilter, value: any) => {\r\n    onChange({\r\n      ...filters,\r\n      [key]: value || undefined,\r\n    });\r\n  };\r\n\r\n  const handleSearchChange = (value: string) => {\r\n    setSearchInput(value);\r\n    // Debounce search\r\n    clearTimeout((window as any).searchTimeout);\r\n    (window as any).searchTimeout = setTimeout(() => {\r\n      handleFilterChange('search', value.trim());\r\n    }, 300);\r\n  };\r\n\r\n  const getActiveFilterCount = () => {\r\n    return Object.values(filters).filter(value => \r\n      value !== undefined && value !== '' && \r\n      !(Array.isArray(value) && value.length === 0)\r\n    ).length;\r\n  };\r\n\r\n  const activeCount = getActiveFilterCount();\r\n\r\n  return (\r\n    <div className=\"task-filters\">\r\n      <div className=\"filters-header\">\r\n        <div className=\"search-box\">\r\n          <input\r\n            type=\"text\"\r\n            placeholder=\"Search tasks...\"\r\n            value={searchInput}\r\n            onChange={(e) => handleSearchChange(e.target.value)}\r\n            className=\"search-input\"\r\n          />\r\n          <span className=\"search-icon\">≡ƒöì</span>\r\n        </div>\r\n        \r\n        <div className=\"filter-controls\">\r\n          <button\r\n            className=\"filter-toggle\"\r\n            onClick={() => setIsExpanded(!isExpanded)}\r\n          >\r\n            Filters {activeCount > 0 && `(${activeCount})`}\r\n            <span className={`toggle-icon ${isExpanded ? 'expanded' : ''}`}>Γû╝</span>\r\n          </button>\r\n          \r\n          {activeCount > 0 && (\r\n            <button\r\n              className=\"reset-filters\"\r\n              onClick={onReset}\r\n            >\r\n              Reset\r\n            </button>\r\n          )}\r\n        </div>\r\n      </div>\r\n\r\n      {isExpanded && (\r\n        <div className=\"filters-content\">\r\n          <div className=\"filter-row\">\r\n            <div className=\"filter-group\">\r\n              <label>Status</label>\r\n              <select\r\n                value={filters.status || ''}\r\n                onChange={(e) => handleFilterChange('status', e.target.value)}\r\n              >\r\n                <option value=\"\">All</option>\r\n                <option value=\"todo\">To Do</option>\r\n                <option value=\"in-progress\">In Progress</option>\r\n                <option value=\"review\">Review</option>\r\n                <option value=\"done\">Done</option>\r\n              </select>\r\n            </div>\r\n\r\n            <div className=\"filter-group\">\r\n              <label>Priority</label>\r\n              <select\r\n                value={filters.priority || ''}\r\n                onChange={(e) => handleFilterChange('priority', e.target.value)}\r\n              >\r\n                <option value=\"\">All</option>\r\n                <option value=\"high\">High</option>\r\n                <option value=\"medium\">Medium</option>\r\n                <option value=\"low\">Low</option>\r\n              </select>\r\n            </div>\r\n\r\n            <div className=\"filter-group\">\r\n              <label>Category</label>\r\n              <select\r\n                value={filters.category || ''}\r\n                onChange={(e) => handleFilterChange('category', e.target.value)}\r\n              >\r\n                <option value=\"\">All</option>\r\n                <option value=\"required_action\">Required Action</option>\r\n                <option value=\"team_action\">Team Action</option>\r\n                <option value=\"job_listing\">Job Listing</option>\r\n                <option value=\"optional_event\">Optional Event</option>\r\n                <option value=\"fyi\">FYI</option>\r\n              </select>\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"filter-row\">\r\n            <div className=\"filter-group\">\r\n              <label>Due Date From</label>\r\n              <input\r\n                type=\"date\"\r\n                value={filters.due_date_from || ''}\r\n                onChange={(e) => handleFilterChange('due_date_from', e.target.value)}\r\n              />\r\n            </div>\r\n\r\n            <div className=\"filter-group\">\r\n              <label>Due Date To</label>\r\n              <input\r\n                type=\"date\"\r\n                value={filters.due_date_to || ''}\r\n                onChange={(e) => handleFilterChange('due_date_to', e.target.value)}\r\n              />\r\n            </div>\r\n\r\n            <div className=\"filter-group checkbox-group\">\r\n              <label>\r\n                <input\r\n                  type=\"checkbox\"\r\n                  checked={filters.overdue || false}\r\n                  onChange={(e) => handleFilterChange('overdue', e.target.checked)}\r\n                />\r\n                Show only overdue\r\n              </label>\r\n            </div>\r\n          </div>\r\n\r\n          <div className=\"filter-row\">\r\n            <div className=\"filter-group\">\r\n              <label>Email ID</label>\r\n              <input\r\n                type=\"text\"\r\n                placeholder=\"Filter by email ID\"\r\n                value={filters.email_id || ''}\r\n                onChange={(e) => handleFilterChange('email_id', e.target.value)}\r\n              />\r\n            </div>\r\n          </div>\r\n        </div>\r\n      )}\r\n    </div>\r\n  );\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\components\\Task\\TaskForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\config\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\hooks\\redux.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\pages\\AccuracyDashboard.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":33,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1044,1047],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1044,1047],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Accuracy Dashboard - Shows classification accuracy statistics\r\nimport React, { useState, useEffect } from 'react';\r\n\r\ninterface AccuracyStat {\r\n  category: string;\r\n  total: number;\r\n  correct: number;\r\n  accuracy: number;\r\n  precision: number;\r\n  recall: number;\r\n  f1: number;\r\n  truePositives: number;\r\n  falsePositives: number;\r\n  falseNegatives: number;\r\n}\r\n\r\nconst AccuracyDashboard: React.FC = () => {\r\n  const [stats, setStats] = useState<AccuracyStat[]>([]);\r\n  const [isLoading, setIsLoading] = useState(true);\r\n\r\n  useEffect(() => {\r\n    // Fetch real accuracy stats from backend\r\n    const fetchAccuracyStats = async () => {\r\n      try {\r\n        const response = await fetch('http://localhost:8000/api/emails/accuracy-stats');\r\n        if (!response.ok) {\r\n          throw new Error('Failed to fetch accuracy stats');\r\n        }\r\n        \r\n        const data = await response.json();\r\n        \r\n        // Transform backend data to match our interface\r\n        const transformedStats: AccuracyStat[] = data.categories.map((cat: any) => ({\r\n          category: cat.category,\r\n          total: cat.total,\r\n          correct: cat.correct,\r\n          accuracy: cat.accuracy,\r\n          precision: cat.precision,\r\n          recall: cat.recall,\r\n          f1: cat.f1,\r\n          truePositives: cat.truePositives,\r\n          falsePositives: cat.falsePositives,\r\n          falseNegatives: cat.falseNegatives,\r\n        }));\r\n        \r\n        setStats(transformedStats);\r\n        setIsLoading(false);\r\n      } catch (error) {\r\n        console.error('Error fetching accuracy stats:', error);\r\n        // Fall back to mock data if API fails\r\n        loadMockData();\r\n      }\r\n    };\r\n    \r\n    const loadMockData = () => {\r\n      const mockStats: AccuracyStat[] = [\r\n      { category: 'Required Personal Action', total: 45, correct: 42, accuracy: 93.3, precision: 95.5, recall: 91.3, f1: 93.3, truePositives: 42, falsePositives: 2, falseNegatives: 4 },\r\n      { category: 'Team Action', total: 38, correct: 35, accuracy: 92.1, precision: 94.6, recall: 89.7, f1: 92.1, truePositives: 35, falsePositives: 2, falseNegatives: 4 },\r\n      { category: 'Optional Action', total: 22, correct: 19, accuracy: 86.4, precision: 90.5, recall: 82.6, f1: 86.4, truePositives: 19, falsePositives: 2, falseNegatives: 4 },\r\n      { category: 'Job Listing', total: 15, correct: 14, accuracy: 93.3, precision: 93.3, recall: 93.3, f1: 93.3, truePositives: 14, falsePositives: 1, falseNegatives: 1 },\r\n      { category: 'Optional Event', total: 18, correct: 16, accuracy: 88.9, precision: 88.9, recall: 88.9, f1: 88.9, truePositives: 16, falsePositives: 2, falseNegatives: 2 },\r\n      { category: 'Work Relevant', total: 52, correct: 48, accuracy: 92.3, precision: 94.1, recall: 90.6, f1: 92.3, truePositives: 48, falsePositives: 3, falseNegatives: 5 },\r\n      { category: 'FYI', total: 67, correct: 63, accuracy: 94.0, precision: 95.5, recall: 92.6, f1: 94.0, truePositives: 63, falsePositives: 3, falseNegatives: 5 },\r\n      { category: 'Newsletter', total: 89, correct: 86, accuracy: 96.6, precision: 97.7, recall: 95.6, f1: 96.6, truePositives: 86, falsePositives: 2, falseNegatives: 4 },\r\n      { category: 'Spam to Delete', total: 34, correct: 33, accuracy: 97.1, precision: 97.1, recall: 97.1, f1: 97.1, truePositives: 33, falsePositives: 1, falseNegatives: 1 },\r\n    ];\r\n    \r\n    setStats(mockStats);\r\n    \r\n    setIsLoading(false);\r\n    };\r\n    \r\n    fetchAccuracyStats();\r\n  }, []);\r\n\r\n  const getAccuracyLevel = (accuracy: number): string => {\r\n    if (accuracy >= 95) return 'excellent';\r\n    if (accuracy >= 90) return 'good';\r\n    if (accuracy >= 85) return 'fair';\r\n    if (accuracy >= 80) return 'poor';\r\n    return 'needs-improvement';\r\n  };\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"page-container\">\r\n        <div className=\"loading-container\">\r\n          <div className=\"loading-container__icon\">≡ƒôè</div>\r\n          <h2 className=\"loading-container__title\">Loading Accuracy Stats</h2>\r\n          <p className=\"loading-container__message\">Please wait...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"page-container\">\r\n      <div className=\"page-header\">\r\n        <h1 className=\"page-title\">≡ƒôè Accuracy Dashboard</h1>\r\n        <p className=\"page-stats\">\r\n          AI classification accuracy statistics\r\n        </p>\r\n      </div>\r\n\r\n      {/* Category Stats Grid - Focus on per-category accuracy */}\r\n      <div className=\"accuracy-stats-grid\">\r\n        {stats.map((stat) => {\r\n          const level = getAccuracyLevel(stat.accuracy);\r\n          return (\r\n            <div\r\n              key={stat.category}\r\n              className={`accuracy-stat-card accuracy-stat-card--${level}`}\r\n            >\r\n              <h3 className=\"accuracy-stat-card__title\">\r\n                {stat.category}\r\n              </h3>\r\n              \r\n              <div className={`accuracy-stat-card__percentage accuracy-stat-card__percentage--${level}`}>\r\n                {stat.accuracy.toFixed(1)}%\r\n              </div>\r\n              \r\n              <div className=\"accuracy-stat-card__fraction\">\r\n                {stat.correct} / {stat.total} correct\r\n              </div>\r\n            \r\n              {/* ML Metrics */}\r\n              <div className=\"accuracy-metrics-grid\">\r\n                <div className=\"accuracy-metric accuracy-metric--precision\">\r\n                  <div className=\"accuracy-metric__label accuracy-metric__label--precision\">Precision</div>\r\n                  <div className=\"accuracy-metric__value\">{stat.precision.toFixed(1)}%</div>\r\n                </div>\r\n                <div className=\"accuracy-metric accuracy-metric--recall\">\r\n                  <div className=\"accuracy-metric__label accuracy-metric__label--recall\">Recall</div>\r\n                  <div className=\"accuracy-metric__value\">{stat.recall.toFixed(1)}%</div>\r\n                </div>\r\n                <div className=\"accuracy-metric accuracy-metric--f1\">\r\n                  <div className=\"accuracy-metric__label accuracy-metric__label--f1\">F1</div>\r\n                  <div className=\"accuracy-metric__value\">{stat.f1.toFixed(1)}%</div>\r\n                </div>\r\n              </div>\r\n              \r\n              {/* Progress bar */}\r\n              <div className=\"accuracy-progress-bar\">\r\n                <div \r\n                  className={`accuracy-progress-bar__fill accuracy-progress-bar__fill--${level}`}\r\n                  style={{ width: `${stat.accuracy}%` }}\r\n                />\r\n              </div>\r\n              \r\n              {/* Confusion Matrix Mini Summary */}\r\n              <div className=\"accuracy-confusion-summary\">\r\n                <span>TP: {stat.truePositives}</span>\r\n                <span>FP: {stat.falsePositives}</span>\r\n                <span>FN: {stat.falseNegatives}</span>\r\n              </div>\r\n            </div>\r\n          );\r\n        })}\r\n      </div>\r\n\r\n      {/* Legend */}\r\n      <div className=\"accuracy-legend\">\r\n        <h4 className=\"accuracy-legend__title\">\r\n          Accuracy Rating Legend:\r\n        </h4>\r\n        <div className=\"accuracy-legend__items\">\r\n          <div className=\"accuracy-legend__item\">\r\n            <div className=\"accuracy-legend__color-box accuracy-legend__color-box--excellent\" />\r\n            <span className=\"accuracy-legend__label\">Excellent (95%+)</span>\r\n          </div>\r\n          <div className=\"accuracy-legend__item\">\r\n            <div className=\"accuracy-legend__color-box accuracy-legend__color-box--good\" />\r\n            <span className=\"accuracy-legend__label\">Good (90-94%)</span>\r\n          </div>\r\n          <div className=\"accuracy-legend__item\">\r\n            <div className=\"accuracy-legend__color-box accuracy-legend__color-box--fair\" />\r\n            <span className=\"accuracy-legend__label\">Fair (85-89%)</span>\r\n          </div>\r\n          <div className=\"accuracy-legend__item\">\r\n            <div className=\"accuracy-legend__color-box accuracy-legend__color-box--poor\" />\r\n            <span className=\"accuracy-legend__label\">Poor (80-84%)</span>\r\n          </div>\r\n          <div className=\"accuracy-legend__item\">\r\n            <div className=\"accuracy-legend__color-box accuracy-legend__color-box--needs-improvement\" />\r\n            <span className=\"accuracy-legend__label\">Needs Improvement (&lt;80%)</span>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default AccuracyDashboard;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\pages\\Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\pages\\EmailDetail.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\pages\\EmailList.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has a missing dependency: 'currentData'. Either include it or remove the dependency array.","line":142,"column":6,"nodeType":"ArrayExpression","endLine":142,"endColumn":27,"suggestions":[{"desc":"Update the dependencies array to be: [currentData]","fix":{"range":[5900,5921],"text":"[currentData]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":238,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":238,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9908,9911],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9908,9911],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from 'react-hooks/exhaustive-deps').","line":309,"column":5,"severity":1,"nodeType":null,"fix":{"range":[12456,12511],"text":" "}},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useMemo has an unnecessary dependency: 'classifiedEmails'. Either exclude it or remove the dependency array.","line":435,"column":6,"nodeType":"ArrayExpression","endLine":435,"endColumn":66,"suggestions":[{"desc":"Update the dependencies array to be: [currentPageConversations, classifyingIds]","fix":{"range":[17580,17640],"text":"[currentPageConversations, classifyingIds]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'currentPageEmails'. Either include it or remove the dependency array.","line":442,"column":6,"nodeType":"ArrayExpression","endLine":442,"endColumn":49,"suggestions":[{"desc":"Update the dependencies array to be: [currentPageEmails, currentPageEmails.length, selectedEmailId]","fix":{"range":[17838,17881],"text":"[currentPageEmails, currentPageEmails.length, selectedEmailId]"}}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleApplyAllToOutlook' is assigned a value but never used.","line":476,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":476,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'handleExtractTasks' is assigned a value but never used.","line":534,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":534,"endColumn":27}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'classifiedEmails'. Either include it or remove the dependency array.","line":395,"column":6,"nodeType":"ArrayExpression","endLine":395,"endColumn":101,"suggestions":[{"desc":"Update the dependencies array to be: [currentConversationPage, isClassifying, conversationGroups, totalPages, classifyConversations, classifiedEmails]","fix":{"range":[16007,16102],"text":"[currentConversationPage, isClassifying, conversationGroups, totalPages, classifyConversations, classifiedEmails]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":3,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":1,"source":"// Complete email list interface with AI categorization\r\nimport React, { useState, useMemo, useCallback, useEffect } from 'react';\r\nimport { useGetEmailsQuery, useBulkApplyToOutlookMutation, useSyncEmailsToDatabaseMutation, useExtractTasksFromEmailsMutation } from '@/services/emailApi';\r\nimport { useClassifyEmailMutation } from '@/services/aiApi';\r\nimport { EmailItem } from '@/components/Email/EmailItem';\r\nimport { EmailActions } from '@/components/Email/EmailActions';\r\nimport { ProgressBar } from '@/components/Email/ProgressBar';\r\nimport { EmailDetailView } from '@/components/Email/EmailDetailView';\r\nimport type { Email } from '@/types/email';\r\n\r\nconst EmailList: React.FC = () => {\r\n  const [selectedEmails, setSelectedEmails] = useState<string[]>([]);\r\n  const [selectedEmailId, setSelectedEmailId] = useState<string | null>(null); // For split view\r\n  const [sortBy, setSortBy] = useState<'date' | 'sender' | 'subject'>('date');\r\n  const [sortOrder, setSortOrder] = useState<'asc' | 'desc'>('desc');\r\n  const [classifyEmail] = useClassifyEmailMutation();\r\n  const [bulkApplyToOutlook] = useBulkApplyToOutlookMutation();\r\n  const [syncEmailsToDatabase] = useSyncEmailsToDatabaseMutation();\r\n  const [extractTasksFromEmails] = useExtractTasksFromEmailsMutation();\r\n  const [isApplyingToOutlook, setIsApplyingToOutlook] = useState(false);\r\n  const [isExtractingTasks, setIsExtractingTasks] = useState(false);\r\n  \r\n  // Initialize refs from sessionStorage to persist across page reloads\r\n  const classifiedEmailsRef = React.useRef<Map<string, Email>>(new Map());\r\n  \r\n  // Load from sessionStorage on mount\r\n  React.useEffect(() => {\r\n    try {\r\n      const stored = sessionStorage.getItem('classifiedEmails');\r\n      if (stored) {\r\n        const parsed = JSON.parse(stored);\r\n        const map = new Map(Object.entries(parsed)) as Map<string, Email>;\r\n        classifiedEmailsRef.current = map;\r\n        setClassifiedEmails(map);\r\n        console.log('[EmailList] Restored', map.size, 'classified emails from sessionStorage');\r\n      }\r\n    } catch (e) {\r\n      console.warn('Failed to load classified emails from sessionStorage:', e);\r\n    }\r\n  }, []); // Run once on mount\r\n  \r\n  const [classifiedEmails, setClassifiedEmails] = useState<Map<string, Email>>(new Map());\r\n  const [classifyingIds, setClassifyingIds] = useState<Set<string>>(new Set());\r\n  \r\n  // Progress tracking for classification\r\n  const [classificationProgress, setClassificationProgress] = useState({ current: 0, total: 0 });\r\n  const [isClassifying, setIsClassifying] = useState(false);\r\n  \r\n  // Pagination state for conversations\r\n  const [currentConversationPage, setCurrentConversationPage] = useState(0);\r\n  const CONVERSATIONS_PER_PAGE = 10;\r\n  \r\n  const {\r\n    data: emailData,\r\n    isLoading,\r\n    error,\r\n    refetch,\r\n  } = useGetEmailsQuery({ limit: 50000 });\r\n\r\n  // Debug logging to diagnose email loading issues\r\n  useEffect(() => {\r\n    console.log('[EmailList Debug] Query state:', {\r\n      isLoading,\r\n      hasError: !!error,\r\n      error: error,\r\n      hasData: !!emailData,\r\n      emailCount: emailData?.emails?.length || 0,\r\n      totalEmails: emailData?.total || 0\r\n    });\r\n  }, [isLoading, error, emailData]);\r\n\r\n  // Persist classification state to sessionStorage\r\n  useEffect(() => {\r\n    try {\r\n      // Convert Map to object for JSON serialization\r\n      const emailsObj = Object.fromEntries(classifiedEmailsRef.current);\r\n      sessionStorage.setItem('classifiedEmails', JSON.stringify(emailsObj));\r\n      \r\n      // Persist classified pages\r\n      const pagesArray = Array.from(classifiedPagesRef.current);\r\n      sessionStorage.setItem('classifiedPages', JSON.stringify(pagesArray));\r\n    } catch (e) {\r\n      console.warn('Failed to persist classification state:', e);\r\n    }\r\n  }, [classifiedEmails]); // Trigger when classifiedEmails state changes\r\n\r\n  // Current data\r\n  const currentData = emailData;\r\n  const currentLoading = isLoading;\r\n  const currentError = error;\r\n\r\n  // Cleanup on unmount - abort any pending prefetch operations\r\n  useEffect(() => {\r\n    return () => {\r\n      if (prefetchAbortControllerRef.current) {\r\n        prefetchAbortControllerRef.current.abort();\r\n      }\r\n    };\r\n  }, []);\r\n\r\n  // Group emails by conversation (like Python app)\r\n  const conversationGroups = useMemo(() => {\r\n    console.log('[EmailList Debug] Building conversation groups from data:', {\r\n      hasData: !!currentData,\r\n      emailsArray: currentData?.emails,\r\n      emailCount: currentData?.emails?.length || 0\r\n    });\r\n    \r\n    if (!currentData?.emails) return [];\r\n    \r\n    const groups = new Map<string, Email[]>();\r\n    \r\n    currentData.emails.forEach(email => {\r\n      const conversationId = email.conversation_id || `single_${email.id}`;\r\n      if (!groups.has(conversationId)) {\r\n        groups.set(conversationId, []);\r\n      }\r\n      groups.get(conversationId)!.push(email);\r\n    });\r\n    \r\n    // Convert to array and sort by latest email date (most recent first)\r\n    const result = Array.from(groups.entries())\r\n      .map(([conversationId, emails]) => ({\r\n        conversationId,\r\n        emails: emails.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime()),\r\n        latestDate: emails.reduce((latest, email) => {\r\n          const emailDate = new Date(email.date);\r\n          return emailDate > latest ? emailDate : latest;\r\n        }, new Date(0)),\r\n        // Representative email is the most recent one\r\n        representativeEmail: emails.sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())[0]\r\n      }))\r\n      .sort((a, b) => b.latestDate.getTime() - a.latestDate.getTime());\r\n    \r\n    console.log('[EmailList Debug] Conversation groups built:', {\r\n      totalGroups: result.length,\r\n      firstGroup: result[0],\r\n      groupSizes: result.slice(0, 5).map(g => g.emails.length)\r\n    });\r\n    \r\n    return result;\r\n  }, [currentData?.emails]);\r\n\r\n  // Get current page of conversations\r\n  const totalConversations = conversationGroups.length;\r\n  const totalPages = Math.ceil(totalConversations / CONVERSATIONS_PER_PAGE);\r\n  const currentPageConversations = useMemo(() => {\r\n    const startIdx = currentConversationPage * CONVERSATIONS_PER_PAGE;\r\n    const endIdx = startIdx + CONVERSATIONS_PER_PAGE;\r\n    return conversationGroups.slice(startIdx, endIdx);\r\n  }, [conversationGroups, currentConversationPage]);\r\n\r\n  // Auto-classify conversations when page changes (like Python app: classify 10 conversations at a time)\r\n  // Use a ref to track which pages have been classified to prevent re-classification\r\n  const classifiedPagesRef = React.useRef<Set<number>>(new Set());\r\n  \r\n  // Load classified pages from sessionStorage on mount\r\n  React.useEffect(() => {\r\n    try {\r\n      const stored = sessionStorage.getItem('classifiedPages');\r\n      if (stored) {\r\n        classifiedPagesRef.current = new Set(JSON.parse(stored));\r\n      }\r\n    } catch (e) {\r\n      console.warn('Failed to load classified pages from sessionStorage:', e);\r\n    }\r\n  }, []); // Run once on mount\r\n  \r\n  const prefetchAbortControllerRef = React.useRef<AbortController | null>(null);\r\n  const isPrefetchingRef = React.useRef(false);\r\n  const [isPrefetchingState, setIsPrefetchingState] = useState(false);\r\n  \r\n  // Helper function to classify a batch of conversations\r\n  const classifyConversations = useCallback(async (\r\n    conversations: typeof currentPageConversations,\r\n    isPrefetch = false,\r\n    abortSignal?: AbortSignal\r\n  ) => {\r\n    if (conversations.length === 0) return;\r\n    \r\n    // Get representative emails from conversations that need classification\r\n    const conversationsToClassify = conversations.filter(conv => {\r\n      const repEmail = conv.representativeEmail;\r\n      // Skip if already classified (check both state and ref) or currently classifying\r\n      if (classifiedEmailsRef.current.has(repEmail.id) || classifyingIds.has(repEmail.id)) {\r\n        return false;\r\n      }\r\n      // Only classify if no AI category yet\r\n      return !repEmail.ai_category;\r\n    });\r\n\r\n    if (conversationsToClassify.length === 0) {\r\n      return;\r\n    }\r\n\r\n    // Only show progress for current page, not prefetch\r\n    if (!isPrefetch) {\r\n      setIsClassifying(true);\r\n      setClassificationProgress({ current: 0, total: conversationsToClassify.length });\r\n    }\r\n\r\n    // Classify one conversation at a time to avoid API limits\r\n    for (let i = 0; i < conversationsToClassify.length; i++) {\r\n      // Check for abort signal\r\n      if (abortSignal?.aborted) {\r\n        console.log('[Prefetch] Classification aborted');\r\n        break;\r\n      }\r\n\r\n      const conversation = conversationsToClassify[i];\r\n      const repEmail = conversation.representativeEmail;\r\n      \r\n      // Mark email as classifying\r\n      setClassifyingIds(prev => new Set(prev).add(repEmail.id));\r\n\r\n      try {\r\n        const result = await classifyEmail({\r\n          subject: repEmail.subject,\r\n          sender: repEmail.sender,\r\n          content: repEmail.body || '',\r\n        }).unwrap();\r\n\r\n        // Apply classification to all emails in the conversation\r\n        // BUT: Don't overwrite manually classified emails\r\n        setClassifiedEmails(prev => {\r\n          const next = new Map(prev);\r\n          conversation.emails.forEach(email => {\r\n            // Check if email was already manually classified\r\n            const existingClassification = classifiedEmailsRef.current.get(email.id);\r\n            if (existingClassification && existingClassification.ai_category) {\r\n              // Email was already classified manually - keep it\r\n              console.log(`[Classification] Skipping email ${email.id.substring(0, 20)}... - already classified as ${existingClassification.ai_category}`);\r\n              return;\r\n            }\r\n            \r\n            const classified = {\r\n              ...email,\r\n              ai_category: result.category as any,\r\n              ai_confidence: result.confidence,\r\n              ai_reasoning: result.reasoning,\r\n              one_line_summary: result.one_line_summary, // Store the AI-generated one-line summary\r\n              classification_status: 'classified' as const,\r\n            };\r\n            next.set(email.id, classified);\r\n            // Also update ref to persist across page changes\r\n            classifiedEmailsRef.current.set(email.id, classified);\r\n          });\r\n          return next;\r\n        });\r\n\r\n        // Update progress only for current page\r\n        if (!isPrefetch) {\r\n          setClassificationProgress({ current: i + 1, total: conversationsToClassify.length });\r\n        }\r\n      } catch (error) {\r\n        console.error(`Failed to classify conversation ${repEmail.id}:`, error);\r\n        // Store as error status for all emails in conversation\r\n        setClassifiedEmails(prev => {\r\n          const next = new Map(prev);\r\n          conversation.emails.forEach(email => {\r\n            const errored = {\r\n              ...email,\r\n              classification_status: 'error' as const,\r\n            };\r\n            next.set(email.id, errored);\r\n            // Also update ref to persist across page changes\r\n            classifiedEmailsRef.current.set(email.id, errored);\r\n          });\r\n          return next;\r\n        });\r\n      } finally {\r\n        // Remove from classifying set\r\n        setClassifyingIds(prev => {\r\n          const next = new Set(prev);\r\n          next.delete(repEmail.id);\r\n          return next;\r\n        });\r\n      }\r\n\r\n      // Delay between classifications to avoid rate limiting\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n    }\r\n    \r\n    // Classification complete\r\n    if (!isPrefetch) {\r\n      setIsClassifying(false);\r\n    }\r\n  }, [classifyEmail, classifyingIds]);\r\n  \r\n  // Classify current page conversations\r\n  useEffect(() => {\r\n    const classifyCurrentPageConversations = async () => {\r\n      if (currentPageConversations.length === 0) return;\r\n      \r\n      // Skip if this page has already been classified\r\n      if (classifiedPagesRef.current.has(currentConversationPage)) {\r\n        return;\r\n      }\r\n\r\n      // Mark this page as being classified\r\n      classifiedPagesRef.current.add(currentConversationPage);\r\n\r\n      // Classify current page\r\n      await classifyConversations(currentPageConversations, false);\r\n    };\r\n\r\n    classifyCurrentPageConversations();\r\n    // Don't include classifiedEmails in dependencies since we're using ref for persistence\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [currentPageConversations, currentConversationPage, classifyConversations]);\r\n\r\n  // PREFETCH: Classify next page in background for instant navigation\r\n  useEffect(() => {\r\n    // Abort any existing prefetch operation when page changes\r\n    if (prefetchAbortControllerRef.current) {\r\n      prefetchAbortControllerRef.current.abort();\r\n      prefetchAbortControllerRef.current = null;\r\n      isPrefetchingRef.current = false;\r\n    }\r\n\r\n    // Wait for current page to finish classifying before prefetching\r\n    if (isClassifying || isPrefetchingRef.current) {\r\n      return;\r\n    }\r\n\r\n    const prefetchNextPage = async () => {\r\n      const nextPage = currentConversationPage + 1;\r\n      \r\n      // Check if there is a next page and it hasn't been classified yet\r\n      if (nextPage >= totalPages || classifiedPagesRef.current.has(nextPage)) {\r\n        return;\r\n      }\r\n\r\n      // Get next page conversations\r\n      const nextPageStartIdx = nextPage * CONVERSATIONS_PER_PAGE;\r\n      const nextPageEndIdx = nextPageStartIdx + CONVERSATIONS_PER_PAGE;\r\n      const nextPageConversations = conversationGroups.slice(nextPageStartIdx, nextPageEndIdx);\r\n\r\n      if (nextPageConversations.length === 0) {\r\n        return;\r\n      }\r\n\r\n      // Check if any conversations on next page need classification\r\n      const needsClassification = nextPageConversations.some(conv => {\r\n        const repEmail = conv.representativeEmail;\r\n        // Check both ref and current state to ensure we don't re-classify\r\n        return !classifiedEmailsRef.current.has(repEmail.id) && \r\n               !classifiedEmails.has(repEmail.id) && \r\n               !repEmail.ai_category;\r\n      });\r\n\r\n      if (!needsClassification) {\r\n        // Mark as classified even though we didn't do work\r\n        classifiedPagesRef.current.add(nextPage);\r\n        return;\r\n      }\r\n\r\n      // Start prefetch after a short delay (user is reading current page)\r\n      const timer = setTimeout(async () => {\r\n        console.log(`[Prefetch] Starting background classification for page ${nextPage + 1} (${nextPageConversations.length} conversations)`);\r\n        isPrefetchingRef.current = true;\r\n        setIsPrefetchingState(true);\r\n        \r\n        // Create abort controller for this prefetch operation\r\n        const abortController = new AbortController();\r\n        prefetchAbortControllerRef.current = abortController;\r\n\r\n        // Mark page as being classified\r\n        classifiedPagesRef.current.add(nextPage);\r\n\r\n        try {\r\n          await classifyConversations(nextPageConversations, true, abortController.signal);\r\n          console.log(`[Prefetch] Completed background classification for page ${nextPage + 1}`);\r\n        } catch (error) {\r\n          if (error instanceof Error && error.name === 'AbortError') {\r\n            console.log('[Prefetch] Classification was aborted');\r\n          } else {\r\n            console.error('[Prefetch] Error during background classification:', error);\r\n          }\r\n        } finally {\r\n          isPrefetchingRef.current = false;\r\n          setIsPrefetchingState(false);\r\n          if (prefetchAbortControllerRef.current === abortController) {\r\n            prefetchAbortControllerRef.current = null;\r\n          }\r\n        }\r\n      }, 2000); // 2 second delay before starting prefetch\r\n\r\n      // Cleanup timer on unmount or page change\r\n      return () => clearTimeout(timer);\r\n    };\r\n\r\n    prefetchNextPage();\r\n    // eslint-disable-next-line react-hooks/exhaustive-deps\r\n  }, [currentConversationPage, isClassifying, conversationGroups, totalPages, classifyConversations]);\r\n\r\n  // Get emails from current page conversations with classification\r\n  const currentPageEmails = useMemo(() => {\r\n    const emails = currentPageConversations.flatMap(conv => conv.emails);\r\n    \r\n    // Deduplicate emails by ID (some emails may appear in multiple conversations)\r\n    const seenIds = new Set<string>();\r\n    const uniqueEmails = emails.filter(email => {\r\n      if (seenIds.has(email.id)) {\r\n        return false;\r\n      }\r\n      seenIds.add(email.id);\r\n      return true;\r\n    });\r\n    \r\n    console.log('[EmailList Debug] currentPageEmails calculation:', {\r\n      conversationsOnPage: currentPageConversations.length,\r\n      totalEmailsFromConversations: emails.length,\r\n      uniqueEmailsAfterDedup: uniqueEmails.length,\r\n      duplicatesRemoved: emails.length - uniqueEmails.length,\r\n      sampleConversation: currentPageConversations[0]\r\n    });\r\n    \r\n    return uniqueEmails.map(email => {\r\n      // Check ref first for persisted classifications\r\n      const classified = classifiedEmailsRef.current.get(email.id);\r\n      if (classified) {\r\n        return classified;\r\n      }\r\n      // Mark as classifying if in progress\r\n      if (classifyingIds.has(email.id)) {\r\n        return { ...email, classification_status: 'classifying' as const };\r\n      }\r\n      // If no AI category yet, mark as pending\r\n      if (!email.ai_category) {\r\n        return { ...email, classification_status: 'pending' as const };\r\n      }\r\n      return email;\r\n    });\r\n  }, [currentPageConversations, classifiedEmails, classifyingIds]);\r\n\r\n  // Auto-select first email when page loads\r\n  useEffect(() => {\r\n    if (currentPageEmails.length > 0 && !selectedEmailId) {\r\n      setSelectedEmailId(currentPageEmails[0].id);\r\n    }\r\n  }, [currentPageEmails.length, selectedEmailId]);\r\n\r\n  // Handle email selection\r\n  const handleEmailSelect = useCallback((emailId: string) => {\r\n    setSelectedEmails(prev => \r\n      prev.includes(emailId) \r\n        ? prev.filter(id => id !== emailId)\r\n        : [...prev, emailId]\r\n    );\r\n  }, []);\r\n\r\n  // Handle select all toggle\r\n  const handleSelectAll = useCallback(() => {\r\n    if (!currentData?.emails) return;\r\n    \r\n    const allCurrentIds = currentData.emails.map(email => email.id);\r\n    const allSelected = allCurrentIds.every(id => selectedEmails.includes(id));\r\n    \r\n    if (allSelected) {\r\n      // Deselect all current emails\r\n      setSelectedEmails(prev => prev.filter(id => !allCurrentIds.includes(id)));\r\n    } else {\r\n      // Select all current emails\r\n      setSelectedEmails(prev => [...new Set([...prev, ...allCurrentIds])]);\r\n    }\r\n  }, [currentData?.emails, selectedEmails]);\r\n\r\n  // Handle clear selection\r\n  const handleClearSelection = useCallback(() => {\r\n    setSelectedEmails([]);\r\n  }, []);\r\n\r\n  // Handle apply all classified emails to Outlook\r\n  // @ts-expect-error - Function defined for future use\r\n  const handleApplyAllToOutlook = async () => {\r\n    if (!currentData?.emails) return;\r\n    \r\n    // Get all emails that have been classified (check both API data and local state)\r\n    const allEmailIds = currentData.emails.map(e => e.id);\r\n    const classifiedEmailIds = allEmailIds.filter(id => {\r\n      const classified = classifiedEmailsRef.current.get(id);\r\n      return classified?.ai_category;\r\n    });\r\n    \r\n    if (classifiedEmailIds.length === 0) {\r\n      alert('No classified emails to apply. Please wait for AI classification to complete.');\r\n      return;\r\n    }\r\n    \r\n    if (!window.confirm(`Apply AI classifications and move ${classifiedEmailIds.length} classified email(s) to their respective Outlook folders?\\n\\nThis will run in the background so you can continue working.`)) {\r\n      return;\r\n    }\r\n    \r\n    setIsApplyingToOutlook(true);\r\n    \r\n    // Run in background and show immediate feedback\r\n    setTimeout(() => {\r\n      alert(`≡ƒôü Applying classifications to ${classifiedEmailIds.length} emails in the background...\\n\\nYou can continue working. Check your Outlook folders in a moment.`);\r\n    }, 100);\r\n    \r\n    try {\r\n      const result = await bulkApplyToOutlook({\r\n        emailIds: classifiedEmailIds,\r\n        applyToOutlook: true,\r\n      }).unwrap();\r\n      \r\n      // Build clear message\r\n      const successCount = result.successful || 0;\r\n      const failCount = result.failed || 0;\r\n      const totalProcessed = result.processed || 0;\r\n      \r\n      if (successCount > 0 && failCount === 0) {\r\n        console.log(`Γ£à Successfully moved ${successCount} email(s) to Outlook folders`);\r\n      } else if (successCount > 0 && failCount > 0) {\r\n        console.log(`ΓÜá∩╕Å Moved ${successCount}/${totalProcessed} emails. ${failCount} emails couldn't be moved (may have been deleted or moved already).`);\r\n      } else {\r\n        console.error('Γ¥î Failed to move emails to Outlook folders.');\r\n        if (result.errors && result.errors.length > 0) {\r\n          console.error('Errors:', result.errors.slice(0, 5).join(', '));\r\n        }\r\n      }\r\n      \r\n      refetch(); // Refresh the email list\r\n    } catch (error) {\r\n      console.error('Bulk apply to Outlook failed:', error);\r\n    } finally {\r\n      setIsApplyingToOutlook(false);\r\n    }\r\n  };\r\n\r\n  // Handle extract tasks from classified emails\r\n  // @ts-expect-error - Function defined for future use\r\n  const handleExtractTasks = async () => {\r\n    if (!currentData?.emails) return;\r\n    \r\n    // Get all classified emails\r\n    const classifiedEmails = Array.from(classifiedEmailsRef.current.values());\r\n    \r\n    if (classifiedEmails.length === 0) {\r\n      alert('No classified emails found. Please wait for AI classification to complete.');\r\n      return;\r\n    }\r\n    \r\n    if (!window.confirm(`Extract tasks from ${classifiedEmails.length} classified emails?\\n\\nThis will create tasks for action items, newsletters, FYI items, and more.`)) {\r\n      return;\r\n    }\r\n    \r\n    setIsExtractingTasks(true);\r\n    \r\n    try {\r\n      // First, sync classified emails to database\r\n      console.log('Syncing emails to database...');\r\n      const syncResult = await syncEmailsToDatabase({\r\n        emails: classifiedEmails\r\n      }).unwrap();\r\n      \r\n      console.log('Sync result:', syncResult);\r\n      \r\n      // Then extract tasks\r\n      console.log('Extracting tasks from emails...');\r\n      const extractResult = await extractTasksFromEmails({\r\n        email_ids: classifiedEmails.map(e => e.id)\r\n      }).unwrap();\r\n      \r\n      console.log('Extract result:', extractResult);\r\n      \r\n      alert(`Γ£à Success!\\n\\n≡ƒôº Synced ${syncResult.synced_count} emails to database\\n≡ƒôï Started task extraction for ${extractResult.email_count} emails\\n\\nTasks are being created in the background. Check the Tasks page in a moment.`);\r\n      \r\n    } catch (error) {\r\n      console.error('Task extraction failed:', error);\r\n      alert('Γ¥î Failed to extract tasks. Please try again or check the console for details.');\r\n    } finally {\r\n      setIsExtractingTasks(false);\r\n    }\r\n  };\r\n\r\n  // Handle sort change\r\n  const handleSortChange = useCallback((newSortBy: 'date' | 'sender' | 'subject') => {\r\n    if (sortBy === newSortBy) {\r\n      setSortOrder(prev => prev === 'asc' ? 'desc' : 'asc');\r\n    } else {\r\n      setSortBy(newSortBy);\r\n      setSortOrder('desc');\r\n    }\r\n  }, [sortBy]);\r\n\r\n  // Pagination handlers\r\n  const handleNextPage = useCallback(() => {\r\n    if (currentConversationPage < totalPages - 1) {\r\n      setCurrentConversationPage(prev => prev + 1);\r\n    }\r\n  }, [currentConversationPage, totalPages]);\r\n\r\n  const handlePreviousPage = useCallback(() => {\r\n    if (currentConversationPage > 0) {\r\n      setCurrentConversationPage(prev => prev - 1);\r\n    }\r\n  }, [currentConversationPage]);\r\n\r\n  // Sort emails from current page\r\n  const sortedEmails = useMemo(() => {\r\n    if (!currentPageEmails || currentPageEmails.length === 0) return [];\r\n    \r\n    return [...currentPageEmails].sort((a, b) => {\r\n      let comparison = 0;\r\n      \r\n      switch (sortBy) {\r\n        case 'date':\r\n          comparison = new Date(a.date).getTime() - new Date(b.date).getTime();\r\n          break;\r\n        case 'sender':\r\n          comparison = a.sender.localeCompare(b.sender);\r\n          break;\r\n        case 'subject':\r\n          comparison = a.subject.localeCompare(b.subject);\r\n          break;\r\n      }\r\n      \r\n      return sortOrder === 'desc' ? -comparison : comparison;\r\n    });\r\n  }, [currentPageEmails, sortBy, sortOrder]);\r\n\r\n  // All styles moved to unified.css\r\n\r\n  // Loading state\r\n  if (currentLoading) {\r\n    return (\r\n      <div className=\"email-list-container\">\r\n        <div className=\"email-list-header email-list-header--centered\">\r\n          <div className=\"email-list-loading-overlay\">\r\n            <div className=\"email-list-loading-overlay__icon\">≡ƒôº</div>\r\n            <h2 className=\"email-list-loading-overlay__title\">Loading Emails</h2>\r\n            <ProgressBar\r\n              current={0}\r\n              total={100}\r\n              label=\"Fetching emails from Outlook...\"\r\n              showPercentage={false}\r\n              color=\"#4a90e2\"\r\n            />\r\n            <p className=\"email-list-loading-overlay__message\">\r\n              This may take a moment...\r\n            </p>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  // Error state\r\n  if (currentError) {\r\n    console.error('[EmailList] Error loading emails:', currentError);\r\n    const errorMessage = 'message' in currentError ? currentError.message : \r\n                         'data' in currentError ? JSON.stringify(currentError.data) :\r\n                         'status' in currentError ? `HTTP ${currentError.status}` :\r\n                         'Unknown error';\r\n    \r\n    return (\r\n      <div className=\"email-list-container\">\r\n        <div className=\"email-list-header email-list-header--centered\">\r\n          <div className=\"email-list-error-overlay\">\r\n            <div className=\"email-list-error-overlay__icon\">ΓÜá∩╕Å</div>\r\n            <h2 className=\"email-list-error-overlay__title\">Error Loading Emails</h2>\r\n            <div className=\"email-list-error-overlay__details\">\r\n              <strong>Error Details:</strong><br/>\r\n              {errorMessage}\r\n            </div>\r\n            <p className=\"email-list-error-overlay__help\">\r\n              Make sure the backend server is running on http://localhost:8000\r\n            </p>\r\n            <button \r\n              onClick={refetch}\r\n              className=\"email-list-error-overlay__retry-btn\"\r\n            >\r\n              ≡ƒöä Retry\r\n            </button>\r\n          </div>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <div className=\"email-list-container\">\r\n      {/* Header */}\r\n      <div className=\"email-list-header\">\r\n        <h1 className=\"email-list-title\">Inbox</h1>\r\n        <div className=\"email-list-stats\">\r\n          {currentData && (\r\n            <>\r\n              <span>\r\n                {totalConversations} conversations | Page {currentConversationPage + 1} of {totalPages || 1}\r\n              </span>\r\n              <span>\r\n                | {currentPageEmails.length} emails on this page\r\n              </span>\r\n              {selectedEmails.length > 0 && (\r\n                <span> | {selectedEmails.length} selected</span>\r\n              )}\r\n              {isPrefetchingState && (\r\n                <span className=\"email-list-prefetch-indicator\">\r\n                  ΓÜí Pre-loading next page...\r\n                </span>\r\n              )}\r\n            </>\r\n          )}\r\n        </div>\r\n        \r\n        {/* Single Approve Button - Does Both Operations (Current Page Only) */}\r\n        <button\r\n          onClick={async () => {\r\n            // Get only classified emails from current page\r\n            const currentPageEmailIds = currentPageEmails\r\n              .filter(email => email.ai_category)\r\n              .map(email => email.id);\r\n            \r\n            if (currentPageEmailIds.length === 0) {\r\n              alert('No classified emails on current page to process');\r\n              return;\r\n            }\r\n\r\n            const emailCount = currentPageEmailIds.length;\r\n            if (!window.confirm(`Process ${emailCount} classified email${emailCount !== 1 ? 's' : ''} from current page?\\n\\nΓ£à Apply classifications to Outlook folders\\nΓ£à Extract tasks and summaries\\n\\nThis will run in the background.`)) {\r\n              return;\r\n            }\r\n\r\n            // Run both operations\r\n            setIsApplyingToOutlook(true);\r\n            setIsExtractingTasks(true);\r\n\r\n            try {\r\n              // 1. Apply to Outlook\r\n              const applyResult = await bulkApplyToOutlook({\r\n                emailIds: currentPageEmailIds,\r\n                applyToOutlook: true,\r\n              }).unwrap();\r\n\r\n              console.log('Γ£à Applied to Outlook:', applyResult);\r\n\r\n              // 2. Sync to database - only current page emails\r\n              const currentPageClassifiedEmails = currentPageEmails.filter(email => \r\n                currentPageEmailIds.includes(email.id)\r\n              );\r\n              const syncResult = await syncEmailsToDatabase({\r\n                emails: currentPageClassifiedEmails\r\n              }).unwrap();\r\n\r\n              console.log('Γ£à Synced to database:', syncResult);\r\n\r\n              // 3. Extract tasks\r\n              const extractResult = await extractTasksFromEmails({\r\n                email_ids: currentPageEmailIds\r\n              }).unwrap();\r\n\r\n              console.log('Γ£à Extracting tasks:', extractResult);\r\n\r\n              alert(`Γ£à Success!\\n\\n≡ƒôü Moved ${applyResult.successful} emails to Outlook folders\\n≡ƒÆ╛ Synced ${syncResult.synced_count} emails to database\\n≡ƒôï Extracting tasks from ${extractResult.email_count} emails\\n\\nCheck the Tasks page in a moment!`);\r\n\r\n              refetch();\r\n            } catch (error) {\r\n              console.error('Error processing emails:', error);\r\n              alert('Γ¥î Some operations failed. Check console for details.');\r\n            } finally {\r\n              setIsApplyingToOutlook(false);\r\n              setIsExtractingTasks(false);\r\n            }\r\n          }}\r\n          disabled={\r\n            isApplyingToOutlook || \r\n            isExtractingTasks || \r\n            isClassifying || \r\n            currentPageEmails.filter(e => e.ai_category).length === 0\r\n          }\r\n          className=\"email-approve-button\"\r\n          title={\r\n            isClassifying \r\n              ? 'Please wait for classification to complete'\r\n              : currentPageEmails.filter(e => e.ai_category).length === 0\r\n              ? 'No classified emails on current page'\r\n              : 'Apply classifications to Outlook AND extract tasks for current page only!'\r\n          }\r\n        >\r\n          <span className=\"email-list-checkmark\">Γ£à</span>\r\n          {isApplyingToOutlook || isExtractingTasks ? 'Processing...' : `Approve ${currentPageEmails.filter(e => e.ai_category).length} Email${currentPageEmails.filter(e => e.ai_category).length !== 1 ? 's' : ''}`}\r\n        </button>\r\n      </div>\r\n\r\n      {/* Content */}\r\n      <div className=\"email-content-area\">\r\n        {/* Classification Progress Bar */}\r\n        {isClassifying && classificationProgress.total > 0 ? (\r\n          <ProgressBar\r\n            current={classificationProgress.current}\r\n            total={classificationProgress.total}\r\n            label=\"Classifying emails with AI...\"\r\n            showPercentage={true}\r\n            color=\"#4a90e2\"\r\n          />\r\n        ) : null}\r\n\r\n        {/* Bulk Actions */}\r\n        <EmailActions\r\n          selectedEmails={selectedEmails}\r\n          onClear={handleClearSelection}\r\n        />\r\n\r\n        {/* Pagination Controls */}\r\n        {totalPages > 1 && (\r\n          <div className=\"email-pagination\">\r\n            <button\r\n              onClick={handlePreviousPage}\r\n              disabled={currentConversationPage === 0}\r\n              className=\"email-pagination-button\"\r\n            >\r\n              ΓåÉ Previous 10 Conversations\r\n            </button>\r\n            \r\n            <span className=\"email-pagination-info\">\r\n              Showing conversations {currentConversationPage * CONVERSATIONS_PER_PAGE + 1}-\r\n              {Math.min((currentConversationPage + 1) * CONVERSATIONS_PER_PAGE, totalConversations)} of {totalConversations}\r\n            </span>\r\n            \r\n            <button\r\n              onClick={handleNextPage}\r\n              disabled={currentConversationPage >= totalPages - 1}\r\n              className=\"email-pagination-button\"\r\n            >\r\n              Next 10 Conversations ΓåÆ\r\n            </button>\r\n          </div>\r\n        )}\r\n\r\n        {/* Email List and Detail - Split View */}\r\n        <div className=\"email-list-split-view\">\r\n          {/* Email List - Left Side */}\r\n          <div className={`email-list-panel ${selectedEmailId ? 'email-list-panel--split' : ''}`}>\r\n            {/* Sort Controls */}\r\n            <div className=\"email-list-sort-controls\">\r\n              <span className=\"email-list-sort-label\">\r\n                Sort by:\r\n              </span>\r\n              <button\r\n                onClick={() => handleSortChange('date')}\r\n                className={`email-list-sort-btn ${sortBy === 'date' ? 'email-list-sort-btn--active' : ''}`}\r\n              >\r\n                Date {sortBy === 'date' && (sortOrder === 'desc' ? 'Γåô' : 'Γåæ')}\r\n              </button>\r\n              <button\r\n                onClick={() => handleSortChange('sender')}\r\n                className={`email-list-sort-btn ${sortBy === 'sender' ? 'email-list-sort-btn--active' : ''}`}\r\n              >\r\n                Sender {sortBy === 'sender' && (sortOrder === 'desc' ? 'Γåô' : 'Γåæ')}\r\n              </button>\r\n              <button\r\n                onClick={() => handleSortChange('subject')}\r\n                className={`email-list-sort-btn ${sortBy === 'subject' ? 'email-list-sort-btn--active' : ''}`}\r\n              >\r\n                Subject {sortBy === 'subject' && (sortOrder === 'desc' ? 'Γåô' : 'Γåæ')}\r\n              </button>\r\n              \r\n              {/* Select All */}\r\n              {sortedEmails.length > 0 && (\r\n                <button\r\n                  onClick={handleSelectAll}\r\n                  className=\"email-list-sort-btn email-list-sort-btn--select-all\"\r\n                >\r\n                  {sortedEmails.every(email => selectedEmails.includes(email.id)) ? 'Deselect All' : 'Select All'}\r\n                </button>\r\n              )}\r\n            </div>\r\n\r\n            {/* Email Items */}\r\n            {sortedEmails.length === 0 ? (\r\n              <div className=\"email-list-empty-state\">\r\n                <div className=\"email-list-empty-state__icon\">≡ƒô¡</div>\r\n                <div className=\"email-list-empty-state__title\">No emails found</div>\r\n              </div>\r\n            ) : (\r\n              <div className=\"email-list-items-container\">\r\n                {sortedEmails.map((email) => (\r\n                  <EmailItem\r\n                    key={email.id}\r\n                    email={email}\r\n                    isSelected={selectedEmails.includes(email.id)}\r\n                    onSelect={() => handleEmailSelect(email.id)}\r\n                    onEmailClick={(emailId) => setSelectedEmailId(emailId)}\r\n                  />\r\n                ))}\r\n              </div>\r\n            )}\r\n          </div>\r\n\r\n          {/* Email Detail - Right Side */}\r\n          {selectedEmailId && (\r\n            <div className=\"email-list-panel\" key={selectedEmailId}>\r\n              <EmailDetailView\r\n                emailId={selectedEmailId}\r\n                onClose={() => setSelectedEmailId(null)}\r\n              />\r\n            </div>\r\n          )}\r\n\r\n          {/* Placeholder when no email selected */}\r\n          {!selectedEmailId && (\r\n            <div className=\"email-list-placeholder\">\r\n              ΓåÉ Select an email to view details\r\n            </div>\r\n          )}\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default EmailList;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\pages\\FYI.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":28,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[955,958],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[955,958],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":89,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2508,2511],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2508,2511],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\*.","line":148,"column":66,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":148,"endColumn":67,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4864,4865],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4864,4864],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\*.","line":150,"column":55,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":150,"endColumn":56,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4983,4984],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4983,4983],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":4,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// FYI page - Shows FYI summaries from tasks\r\nimport React, { useMemo } from 'react';\r\nimport { useGetTasksQuery, useUpdateTaskMutation, useDeleteTaskMutation } from '@/services/taskApi';\r\nimport type { Task } from '@/types/task';\r\n\r\nconst FYI: React.FC = () => {\r\n  const [updateTask] = useUpdateTaskMutation();\r\n  const [deleteTask] = useDeleteTaskMutation();\r\n\r\n  const {\r\n    data: taskData,\r\n    isLoading,\r\n    error,\r\n    refetch,\r\n  } = useGetTasksQuery({ page: 1, per_page: 1000 });\r\n\r\n  // Filter for FYI tasks - hide completed ones\r\n  const fyiTasks = useMemo(() => {\r\n    if (!taskData?.tasks) return [];\r\n    return taskData.tasks.filter(task => task.category === 'fyi' && task.status !== 'done');\r\n  }, [taskData?.tasks]);\r\n\r\n  const handleToggleRead = async (task: Task) => {\r\n    try {\r\n      const newStatus = task.status === 'done' ? 'todo' : 'done';\r\n      await updateTask({\r\n        id: task.id,\r\n        data: { status: newStatus as any }\r\n      }).unwrap();\r\n      refetch();\r\n    } catch (error) {\r\n      console.error('Failed to update task:', error);\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (taskId: string) => {\r\n    if (!window.confirm('Delete this FYI item?')) {\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      await deleteTask(taskId).unwrap();\r\n      refetch();\r\n    } catch (error) {\r\n      console.error('Failed to delete task:', error);\r\n    }\r\n  };\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"page-container\">\r\n        <div className=\"loading-container\">\r\n          <div className=\"loading-container__icon\">Γä╣∩╕Å</div>\r\n          <h2 className=\"loading-container__title\">Loading FYI Emails</h2>\r\n          <p className=\"loading-container__message\">Please wait...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (error) {\r\n    return (\r\n      <div className=\"page-container\">\r\n        <div className=\"error-container\">\r\n          <div className=\"text-2xl mb-sm\">ΓÜá∩╕Å</div>\r\n          <div>Error loading FYI emails</div>\r\n          <button \r\n            onClick={refetch}\r\n            className=\"synthwave-button mt-md\"\r\n          >\r\n            Retry\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const handleDismissAll = async () => {\r\n    if (!window.confirm(`Dismiss all ${fyiTasks.length} FYI items?`)) {\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      // Mark all FYI items as done\r\n      await Promise.all(\r\n        fyiTasks.map(task => \r\n          updateTask({\r\n            id: task.id,\r\n            data: { status: 'done' as any }\r\n          }).unwrap()\r\n        )\r\n      );\r\n      refetch();\r\n    } catch (error) {\r\n      console.error('Failed to dismiss all FYI items:', error);\r\n      alert('Failed to dismiss all FYI items');\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"page-container\">\r\n      <div className=\"page-header\">\r\n        <h1 className=\"page-title\">Γä╣∩╕Å FYI</h1>\r\n        <div className=\"page-stats\">\r\n          {fyiTasks.length} FYI item{fyiTasks.length !== 1 ? 's' : ''}\r\n        </div>\r\n        {fyiTasks.length > 0 && (\r\n          <button\r\n            onClick={handleDismissAll}\r\n            className=\"synthwave-button-secondary dismiss-all-btn\"\r\n          >\r\n            Dismiss All\r\n          </button>\r\n        )}\r\n      </div>\r\n\r\n      <div className=\"page-content\">\r\n        {fyiTasks.length === 0 ? (\r\n          <div className=\"empty-state\">\r\n            <div className=\"empty-state__icon\">≡ƒô¡</div>\r\n            <div className=\"empty-state__title\">No FYI items yet</div>\r\n            <div className=\"empty-state__description\">Extract tasks from emails to see FYI summaries here</div>\r\n          </div>\r\n        ) : (\r\n          <div className=\"flex-column gap-12\">\r\n            {fyiTasks.map((task) => {\r\n              const isDone = task.status === 'done';\r\n              return (\r\n                <div\r\n                  key={task.id}\r\n                  className={`fyi-item ${isDone ? 'fyi-item--done' : ''}`}\r\n                >\r\n                  <input\r\n                    type=\"checkbox\"\r\n                    checked={isDone}\r\n                    onChange={() => handleToggleRead(task)}\r\n                    className=\"fyi-item__checkbox\"\r\n                  />\r\n                  <div className=\"fyi-item__content\">\r\n                    {/* Show only summary text without extra email metadata */}\r\n                    <div className={`fyi-item__text ${isDone ? 'fyi-item__text--done' : ''}`}>\r\n                      {/* Extract bullet points if present, otherwise show full description */}\r\n                      {task.description?.split('\\n').map((line, idx) => {\r\n                        const trimmedLine = line.trim();\r\n                        if (!trimmedLine) return null;\r\n                        \r\n                        // Check if line starts with bullet point or dash\r\n                        const isBullet = trimmedLine.match(/^[ΓÇó\\-\\*]\\s/);\r\n                        const cleanedLine = isBullet \r\n                          ? trimmedLine.replace(/^[ΓÇó\\-\\*]\\s/, '') \r\n                          : trimmedLine;\r\n                        \r\n                        // Skip common email header patterns\r\n                        if (cleanedLine.match(/^(From:|To:|Subject:|Date:|Sent:)/i)) {\r\n                          return null;\r\n                        }\r\n                        \r\n                        return (\r\n                          <div key={idx} className=\"fyi-item__line\">\r\n                            {isBullet && <span className=\"fyi-item__bullet\">ΓÇó</span>}\r\n                            {cleanedLine}\r\n                          </div>\r\n                        );\r\n                      }).filter(Boolean)}\r\n                    </div>\r\n                  </div>\r\n                  <button\r\n                    onClick={() => handleDelete(task.id)}\r\n                    className=\"fyi-item__delete-btn\"\r\n                    title=\"Delete\"\r\n                  >\r\n                    ≡ƒùæ∩╕Å\r\n                  </button>\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default FYI;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\pages\\Newsletters.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1239,1242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1239,1242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":95,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2822,2825],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2822,2825],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Newsletters page - Shows newsletter summaries from tasks\r\nimport React, { useMemo } from 'react';\r\nimport { useGetTasksQuery, useUpdateTaskMutation, useDeleteTaskMutation } from '@/services/taskApi';\r\nimport type { Task } from '@/types/task';\r\n\r\nconst Newsletters: React.FC = () => {\r\n  const [updateTask] = useUpdateTaskMutation();\r\n  const [deleteTask] = useDeleteTaskMutation();\r\n\r\n  const {\r\n    data: taskData,\r\n    isLoading,\r\n    error,\r\n    refetch,\r\n  } = useGetTasksQuery({ page: 1, per_page: 1000 });\r\n\r\n  // Filter for newsletter tasks - hide completed ones and irrelevant ones\r\n  const newsletterTasks = useMemo(() => {\r\n    if (!taskData?.tasks) return [];\r\n    return taskData.tasks.filter(task => {\r\n      if (task.category !== 'newsletter') return false;\r\n      if (task.status === 'done') return false;\r\n      // Hide newsletters marked as irrelevant\r\n      if (task.description?.includes('No content relevant to your interests')) return false;\r\n      return true;\r\n    });\r\n  }, [taskData?.tasks]);\r\n\r\n  const handleToggleRead = async (task: Task) => {\r\n    try {\r\n      const newStatus = task.status === 'done' ? 'todo' : 'done';\r\n      await updateTask({\r\n        id: task.id,\r\n        data: { status: newStatus as any }\r\n      }).unwrap();\r\n      refetch();\r\n    } catch (error) {\r\n      console.error('Failed to update task:', error);\r\n    }\r\n  };\r\n\r\n  const handleDelete = async (taskId: string) => {\r\n    if (!window.confirm('Delete this newsletter summary?')) {\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      await deleteTask(taskId).unwrap();\r\n      refetch();\r\n    } catch (error) {\r\n      console.error('Failed to delete task:', error);\r\n    }\r\n  };\r\n\r\n  if (isLoading) {\r\n    return (\r\n      <div className=\"page-container\">\r\n        <div className=\"loading-container\">\r\n          <div className=\"loading-container__icon\">≡ƒô░</div>\r\n          <h2 className=\"loading-container__title\">Loading Newsletters</h2>\r\n          <p className=\"loading-container__message\">Please wait...</p>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (error) {\r\n    return (\r\n      <div className=\"page-container\">\r\n        <div className=\"error-container\">\r\n          <div className=\"text-2xl mb-sm\">ΓÜá∩╕Å</div>\r\n          <div>Error loading newsletters</div>\r\n          <button \r\n            onClick={refetch}\r\n            className=\"synthwave-button mt-md\"\r\n          >\r\n            Retry\r\n          </button>\r\n        </div>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  const handleDismissAll = async () => {\r\n    if (!window.confirm(`Dismiss all ${newsletterTasks.length} newsletters?`)) {\r\n      return;\r\n    }\r\n    \r\n    try {\r\n      // Mark all newsletters as done\r\n      await Promise.all(\r\n        newsletterTasks.map(task => \r\n          updateTask({\r\n            id: task.id,\r\n            data: { status: 'done' as any }\r\n          }).unwrap()\r\n        )\r\n      );\r\n      refetch();\r\n    } catch (error) {\r\n      console.error('Failed to dismiss all newsletters:', error);\r\n      alert('Failed to dismiss all newsletters');\r\n    }\r\n  };\r\n\r\n  return (\r\n    <div className=\"page-container\">\r\n      <div className=\"page-header\">\r\n        <h1 className=\"page-title\">≡ƒô░ Newsletters</h1>\r\n        <div className=\"page-stats\">\r\n          {newsletterTasks.length} newsletter{newsletterTasks.length !== 1 ? 's' : ''}\r\n        </div>\r\n        {newsletterTasks.length > 0 && (\r\n          <button\r\n            onClick={handleDismissAll}\r\n            className=\"synthwave-button-secondary dismiss-all-btn\"\r\n          >\r\n            Dismiss All\r\n          </button>\r\n        )}\r\n      </div>\r\n\r\n      <div className=\"page-content\">\r\n        {newsletterTasks.length === 0 ? (\r\n          <div className=\"empty-state\">\r\n            <div className=\"empty-state__icon\">≡ƒô¡</div>\r\n            <div className=\"empty-state__title\">No newsletters yet</div>\r\n            <div className=\"empty-state__description\">Extract tasks from emails to see newsletter summaries here</div>\r\n          </div>\r\n        ) : (\r\n          <div className=\"flex-column gap-16\">\r\n            {newsletterTasks.map((task) => {\r\n              const isDone = task.status === 'done';\r\n              return (\r\n                <div\r\n                  key={task.id}\r\n                  className={`newsletter-item ${isDone ? 'newsletter-item--done' : ''}`}\r\n                >\r\n                  <div className=\"newsletter-item__header\">\r\n                    <input\r\n                      type=\"checkbox\"\r\n                      checked={isDone}\r\n                      onChange={() => handleToggleRead(task)}\r\n                      className=\"newsletter-item__checkbox\"\r\n                    />\r\n                    <div className=\"newsletter-item__content\">\r\n                      {/* Show only summary without extra noise - clean newsletter format */}\r\n                      <div className=\"newsletter-item__summary\">\r\n                        {/* Clean up description - remove email headers and format paragraphs */}\r\n                        {task.description?.split('\\n\\n').map((paragraph, idx) => {\r\n                          const trimmedPara = paragraph.trim();\r\n                          \r\n                          // Skip email headers and metadata\r\n                          if (trimmedPara.match(/^(From:|To:|Subject:|Date:|Sent:|Email from)/i)) {\r\n                            return null;\r\n                          }\r\n                          \r\n                          // Skip empty paragraphs\r\n                          if (!trimmedPara) return null;\r\n                          \r\n                          return (\r\n                            <p key={idx} className={`newsletter-item__summary-paragraph ${isDone ? 'newsletter-item__summary--done' : ''} ${idx === 0 ? 'newsletter-item__summary-paragraph--first' : ''}`}>\r\n                              {trimmedPara}\r\n                            </p>\r\n                          );\r\n                        }).filter(Boolean)}\r\n                      </div>\r\n                      \r\n                      {/* Show key points if available */}\r\n                      {task.metadata?.key_points && Array.isArray(task.metadata.key_points) && (task.metadata.key_points as unknown as string[]).length > 0 ? (\r\n                        <div className=\"newsletter-item__highlights\">\r\n                          <strong className=\"newsletter-item__highlights-title\">\r\n                            Key Takeaways:\r\n                          </strong>\r\n                          <ul className=\"newsletter-item__highlights-list\">\r\n                            {(task.metadata.key_points as unknown as string[]).map((point: string, idx: number) => (\r\n                              <li key={idx} className=\"newsletter-item__highlight\">\r\n                                {String(point)}\r\n                              </li>\r\n                            ))}\r\n                          </ul>\r\n                        </div>\r\n                      ) : null}\r\n                    </div>\r\n                    <button\r\n                      onClick={() => handleDelete(task.id)}\r\n                      className=\"newsletter-item__delete-btn\"\r\n                      title=\"Delete\"\r\n                    >\r\n                      ≡ƒùæ∩╕Å\r\n                    </button>\r\n                  </div>\r\n                </div>\r\n              );\r\n            })}\r\n          </div>\r\n        )}\r\n      </div>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Newsletters;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\pages\\Settings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\pages\\TaskList.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\router\\AppRouter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\services\\aiApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\services\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\services\\authApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\services\\emailApi.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":140,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":140,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4585,4588],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4585,4588],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":179,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":179,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5779,5782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5779,5782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Email API service for T2 backend integration\r\nimport { apiSlice } from './api';\r\nimport type {\r\n  Email,\r\n  EmailListResponse,\r\n  EmailFilter,\r\n  EmailBatchOperation,\r\n  EmailStats,\r\n  PaginationParams,\r\n} from '@/types';\r\n\r\nexport const emailApi = apiSlice.injectEndpoints({\r\n  endpoints: (builder) => ({\r\n    // Get paginated list of emails\r\n    getEmails: builder.query<EmailListResponse, PaginationParams & EmailFilter>({\r\n      query: (params) => ({\r\n        url: '/api/emails',\r\n        params,\r\n      }),\r\n      providesTags: (result) =>\r\n        result?.emails\r\n          ? [\r\n              ...result.emails.map(({ id }) => ({ type: 'Email' as const, id })),\r\n              { type: 'Email', id: 'LIST' },\r\n            ]\r\n          : [{ type: 'Email', id: 'LIST' }],\r\n    }),\r\n\r\n    // Search emails\r\n    searchEmails: builder.query<EmailListResponse, { query: string; page?: number; per_page?: number }>({\r\n      query: ({ query, page = 1, per_page = 20 }) => ({\r\n        url: '/api/emails/search',\r\n        params: { q: query, page, per_page },\r\n      }),\r\n      providesTags: (result) =>\r\n        result?.emails\r\n          ? [\r\n              ...result.emails.map(({ id }) => ({ type: 'Email' as const, id })),\r\n              { type: 'Email', id: 'SEARCH' },\r\n            ]\r\n          : [{ type: 'Email', id: 'SEARCH' }],\r\n    }),\r\n\r\n    // Get individual email by ID\r\n    getEmailById: builder.query<Email, string>({\r\n      query: (id) => `/api/emails/${id}`,\r\n      providesTags: (_result, _error, id) => [{ type: 'Email', id }],\r\n      // Cache email details for 5 minutes to prevent redundant fetches\r\n      keepUnusedDataFor: 300,\r\n    }),\r\n\r\n    // Get email statistics\r\n    getEmailStats: builder.query<EmailStats, number>({\r\n      query: (limit = 100) => `/api/emails/stats?limit=${limit}`,\r\n      providesTags: [{ type: 'Email', id: 'STATS' }],\r\n    }),\r\n\r\n    // Batch operations on emails\r\n    batchEmailOperation: builder.mutation<\r\n      { success: boolean; processed_count: number; message: string },\r\n      EmailBatchOperation\r\n    >({\r\n      query: (operation) => ({\r\n        url: '/api/emails/batch',\r\n        method: 'POST',\r\n        body: operation,\r\n      }),\r\n      invalidatesTags: [\r\n        { type: 'Email', id: 'LIST' },\r\n        { type: 'Email', id: 'STATS' },\r\n      ],\r\n    }),\r\n\r\n    // Mark email as read\r\n    markEmailRead: builder.mutation<void, { id: string; read: boolean }>({\r\n      query: ({ id, read }) => ({\r\n        url: `/api/emails/${id}/read`,\r\n        method: 'PUT',\r\n        body: { is_read: read },\r\n      }),\r\n      invalidatesTags: (_result, _error, { id }) => [\r\n        { type: 'Email', id },\r\n        { type: 'Email', id: 'LIST' },\r\n        { type: 'Email', id: 'STATS' },\r\n      ],\r\n    }),\r\n\r\n    // Delete email\r\n    deleteEmail: builder.mutation<void, string>({\r\n      query: (id) => ({\r\n        url: `/api/emails/${id}`,\r\n        method: 'DELETE',\r\n      }),\r\n      invalidatesTags: (_result, _error, id) => [\r\n        { type: 'Email', id },\r\n        { type: 'Email', id: 'LIST' },\r\n        { type: 'Email', id: 'STATS' },\r\n      ],\r\n    }),\r\n\r\n    // Move email to folder\r\n    moveEmail: builder.mutation<void, { id: string; folder: string }>({\r\n      query: ({ id, folder }) => ({\r\n        url: `/api/emails/${id}/move`,\r\n        method: 'PUT',\r\n        body: { folder_name: folder },\r\n      }),\r\n      invalidatesTags: (_result, _error, { id }) => [\r\n        { type: 'Email', id },\r\n        { type: 'Email', id: 'LIST' },\r\n      ],\r\n    }),\r\n\r\n    // Get category to folder mappings\r\n    getCategoryMappings: builder.query<\r\n      Array<{ category: string; folder_name: string; stays_in_inbox: boolean }>,\r\n      void\r\n    >({\r\n      query: () => '/api/emails/category-mappings',\r\n    }),\r\n\r\n    // Update email classification\r\n    updateEmailClassification: builder.mutation<\r\n      { success: boolean; message: string; email_id?: string },\r\n      { emailId: string; category: string; applyToOutlook: boolean }\r\n    >({\r\n      query: ({ emailId, category, applyToOutlook }) => ({\r\n        url: `/api/emails/${emailId}/classification`,\r\n        method: 'PUT',\r\n        body: {\r\n          category,\r\n          apply_to_outlook: applyToOutlook,\r\n        },\r\n      }),\r\n      // Optimistic update for better UX\r\n      async onQueryStarted({ emailId, category }, { dispatch, queryFulfilled }) {\r\n        // Optimistically update the individual email cache\r\n        const patchResult = dispatch(\r\n          emailApi.util.updateQueryData('getEmailById', emailId, (draft) => {\r\n            draft.ai_category = category as any;\r\n            draft.categories = [category];\r\n          })\r\n        );\r\n        try {\r\n          await queryFulfilled;\r\n        } catch {\r\n          // Revert on error\r\n          patchResult.undo();\r\n        }\r\n      },\r\n      invalidatesTags: (_result, _error, { emailId }) => [\r\n        { type: 'Email', id: emailId },\r\n        { type: 'Email', id: 'LIST' },\r\n      ],\r\n    }),\r\n\r\n    // Bulk apply classifications to Outlook\r\n    bulkApplyToOutlook: builder.mutation<\r\n      { success: boolean; processed: number; successful: number; failed: number; errors: string[] },\r\n      { emailIds: string[]; applyToOutlook?: boolean }\r\n    >({\r\n      query: ({ emailIds, applyToOutlook = true }) => ({\r\n        url: '/api/emails/bulk-apply-to-outlook',\r\n        method: 'POST',\r\n        body: {\r\n          email_ids: emailIds,\r\n          apply_to_outlook: applyToOutlook,\r\n        },\r\n      }),\r\n      invalidatesTags: [\r\n        { type: 'Email', id: 'LIST' },\r\n        { type: 'Email', id: 'STATS' },\r\n      ],\r\n    }),\r\n\r\n    // Sync classified emails to database\r\n    syncEmailsToDatabase: builder.mutation<\r\n      { success: boolean; synced_count: number; message: string },\r\n      { emails: any[] }\r\n    >({\r\n      query: (data) => ({\r\n        url: '/api/emails/sync-to-database',\r\n        method: 'POST',\r\n        body: data,\r\n      }),\r\n      invalidatesTags: [\r\n        { type: 'Email', id: 'LIST' },\r\n        { type: 'Email', id: 'STATS' },\r\n      ],\r\n    }),\r\n\r\n    // Extract tasks from emails\r\n    extractTasksFromEmails: builder.mutation<\r\n      { status: string; message: string; email_count: number },\r\n      { email_ids: string[] }\r\n    >({\r\n      query: (data) => ({\r\n        url: '/api/emails/extract-tasks',\r\n        method: 'POST',\r\n        body: {\r\n          email_ids: data.email_ids,\r\n          apply_to_outlook: false,\r\n        },\r\n      }),\r\n      invalidatesTags: [\r\n        { type: 'Task', id: 'LIST' },\r\n        { type: 'Task', id: 'STATS' },\r\n      ],\r\n    }),\r\n  }),\r\n});\r\n\r\nexport const {\r\n  useGetEmailsQuery,\r\n  useSearchEmailsQuery,\r\n  useGetEmailByIdQuery,\r\n  useGetEmailStatsQuery,\r\n  useBatchEmailOperationMutation,\r\n  useMarkEmailReadMutation,\r\n  useDeleteEmailMutation,\r\n  useMoveEmailMutation,\r\n  useGetCategoryMappingsQuery,\r\n  useUpdateEmailClassificationMutation,\r\n  useBulkApplyToOutlookMutation,\r\n  useSyncEmailsToDatabaseMutation,\r\n  useExtractTasksFromEmailsMutation,\r\n} = emailApi;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\services\\settingsApi.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":26,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[733,736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[733,736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":34,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[981,984],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[981,984],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":41,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":41,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1190,1193],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1190,1193],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Settings API service using RTK Query\r\nimport { apiSlice } from './api';\r\n\r\nexport interface UserSettings {\r\n  username?: string;\r\n  job_context?: string;\r\n  newsletter_interests?: string;\r\n  azure_openai_endpoint?: string;\r\n  azure_openai_deployment?: string;\r\n  custom_prompts?: Record<string, string>;\r\n  ado_area_path?: string;\r\n  ado_pat?: string;\r\n}\r\n\r\nexport interface SettingsResponse {\r\n  success: boolean;\r\n  message: string;\r\n  settings?: UserSettings;\r\n}\r\n\r\n// Extend the API slice with settings endpoints\r\nexport const settingsApi = apiSlice.injectEndpoints({\r\n  endpoints: (builder) => ({\r\n    getSettings: builder.query<UserSettings, void>({\r\n      query: () => '/api/settings',\r\n      providesTags: ['Settings'] as any,\r\n    }),\r\n    updateSettings: builder.mutation<SettingsResponse, UserSettings>({\r\n      query: (settings) => ({\r\n        url: '/api/settings',\r\n        method: 'PUT',\r\n        body: settings,\r\n      }),\r\n      invalidatesTags: ['Settings'] as any,\r\n    }),\r\n    resetSettings: builder.mutation<SettingsResponse, void>({\r\n      query: () => ({\r\n        url: '/api/settings',\r\n        method: 'DELETE',\r\n      }),\r\n      invalidatesTags: ['Settings'] as any,\r\n    }),\r\n  }),\r\n});\r\n\r\nexport const {\r\n  useGetSettingsQuery,\r\n  useUpdateSettingsMutation,\r\n  useResetSettingsMutation,\r\n} = settingsApi;\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\services\\taskApi.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\services\\tokenStorage.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":63,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":63,"endColumn":19}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Secure token storage service for JWT tokens\r\nexport interface TokenStorage {\r\n  setTokens(accessToken: string, refreshToken: string, remember?: boolean): void;\r\n  getTokens(): { accessToken: string; refreshToken: string } | null;\r\n  clearTokens(): void;\r\n  isTokenExpired(token: string): boolean;\r\n}\r\n\r\nclass TokenStorageService implements TokenStorage {\r\n  private readonly ACCESS_TOKEN_KEY = 'email_helper_access_token';\r\n  private readonly REFRESH_TOKEN_KEY = 'email_helper_refresh_token';\r\n\r\n  /**\r\n   * Store tokens in localStorage (remember=true) or sessionStorage (remember=false)\r\n   */\r\n  setTokens(accessToken: string, refreshToken: string, remember: boolean = false): void {\r\n    const storage = remember ? localStorage : sessionStorage;\r\n    \r\n    // Clear tokens from both storages first to avoid duplicates\r\n    this.clearTokens();\r\n    \r\n    storage.setItem(this.ACCESS_TOKEN_KEY, accessToken);\r\n    storage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);\r\n  }\r\n\r\n  /**\r\n   * Get tokens from localStorage or sessionStorage\r\n   */\r\n  getTokens(): { accessToken: string; refreshToken: string } | null {\r\n    // Check localStorage first, then sessionStorage\r\n    const accessToken = localStorage.getItem(this.ACCESS_TOKEN_KEY) || \r\n                       sessionStorage.getItem(this.ACCESS_TOKEN_KEY);\r\n    const refreshToken = localStorage.getItem(this.REFRESH_TOKEN_KEY) || \r\n                        sessionStorage.getItem(this.REFRESH_TOKEN_KEY);\r\n    \r\n    if (accessToken && refreshToken) {\r\n      return { accessToken, refreshToken };\r\n    }\r\n    return null;\r\n  }\r\n\r\n  /**\r\n   * Clear all tokens from both localStorage and sessionStorage\r\n   */\r\n  clearTokens(): void {\r\n    localStorage.removeItem(this.ACCESS_TOKEN_KEY);\r\n    localStorage.removeItem(this.REFRESH_TOKEN_KEY);\r\n    sessionStorage.removeItem(this.ACCESS_TOKEN_KEY);\r\n    sessionStorage.removeItem(this.REFRESH_TOKEN_KEY);\r\n  }\r\n\r\n  /**\r\n   * Check if JWT token is expired\r\n   */\r\n  isTokenExpired(token: string): boolean {\r\n    try {\r\n      // Decode JWT payload without verification (client-side check only)\r\n      const payload = JSON.parse(atob(token.split('.')[1]));\r\n      const currentTime = Math.floor(Date.now() / 1000);\r\n      \r\n      // Return true if token is expired (with 30 second buffer for network delays)\r\n      return payload.exp && payload.exp < (currentTime + 30);\r\n    } catch (error) {\r\n      // If token can't be parsed, consider it expired\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get the storage type where tokens are currently stored\r\n   */\r\n  getStorageType(): 'localStorage' | 'sessionStorage' | null {\r\n    if (localStorage.getItem(this.ACCESS_TOKEN_KEY)) {\r\n      return 'localStorage';\r\n    }\r\n    if (sessionStorage.getItem(this.ACCESS_TOKEN_KEY)) {\r\n      return 'sessionStorage';\r\n    }\r\n    return null;\r\n  }\r\n}\r\n\r\nexport const tokenStorage = new TokenStorageService();","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\store\\authSlice.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\store\\store.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\App.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":9,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":9,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[342,345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[342,345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Basic app tests\r\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\r\nimport { render, screen, waitFor } from '@testing-library/react';\r\nimport App from '../App';\r\n\r\n// Mock fetch to prevent real API calls in tests\r\nbeforeEach(() => {\r\n  // Create a proper mock Response with clone() method\r\n  const createMockResponse = (data: any, status = 401, ok = false) => {\r\n    const response = {\r\n      ok,\r\n      status,\r\n      json: () => Promise.resolve(data),\r\n      text: () => Promise.resolve(JSON.stringify(data)),\r\n      headers: new Headers(),\r\n      redirected: false,\r\n      statusText: ok ? 'OK' : 'Unauthorized',\r\n      type: 'basic' as ResponseType,\r\n      url: '',\r\n      // CRITICAL: Add clone() method that fetch API requires\r\n      clone: function() { return { ...this }; },\r\n    };\r\n    return response as Response;\r\n  };\r\n\r\n  global.fetch = vi.fn(() =>\r\n    Promise.resolve(createMockResponse({ detail: 'Not authenticated' }))\r\n  );\r\n});\r\n\r\ndescribe('App Component', () => {\r\n  it('renders without crashing', async () => {\r\n    render(<App />);\r\n    // App should render the router and main navigation\r\n    await waitFor(() => {\r\n      // The app renders with navigation elements\r\n      const hasNav = document.querySelector('.synthwave-nav');\r\n      expect(hasNav).toBeTruthy();\r\n    });\r\n  });\r\n\r\n  it('shows email list by default', async () => {\r\n    render(<App />);\r\n    // Wait for router to render and show inbox\r\n    await waitFor(() => {\r\n      // Should show inbox/email list as default route\r\n      // The component will show either the inbox, loading state, or error state\r\n      const hasEmailContent = \r\n        screen.queryByText('Inbox') || \r\n        screen.queryByText('Loading Emails') ||\r\n        screen.queryByText('Error Loading Emails');\r\n      expect(hasEmailContent).toBeTruthy();\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\EmailItem.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\EmailList.test.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'fireEvent' is defined but never used.","line":3,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":35}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Email list component tests\r\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\r\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\r\nimport { Provider } from 'react-redux';\r\nimport { BrowserRouter } from 'react-router-dom';\r\nimport { configureStore } from '@reduxjs/toolkit';\r\nimport EmailList from '@/pages/EmailList';\r\nimport { apiSlice } from '@/services/api';\r\nimport authSlice from '@/store/authSlice';\r\n\r\n// Mock data - commented out as not currently used\r\n/*\r\nconst mockEmails = [\r\n  {\r\n    id: '1',\r\n    subject: 'Test Email 1',\r\n    sender: 'test1@example.com',\r\n    recipient: 'user@example.com',\r\n    date: '2025-01-15T10:00:00Z',\r\n    body: 'This is a test email body content.',\r\n    is_read: false,\r\n    importance: 'Normal' as const,\r\n    has_attachments: false,\r\n    categories: ['required_action'],\r\n  },\r\n  {\r\n    id: '2',\r\n    subject: 'Test Email 2',\r\n    sender: 'test2@example.com',\r\n    recipient: 'user@example.com',\r\n    date: '2025-01-14T15:30:00Z',\r\n    body: 'Another test email with different content.',\r\n    is_read: true,\r\n    importance: 'High' as const,\r\n    has_attachments: true,\r\n    categories: ['fyi'],\r\n  },\r\n];\r\n*/\r\n\r\n// Create test store\r\nconst createTestStore = () => {\r\n  return configureStore({\r\n    reducer: {\r\n      api: apiSlice.reducer,\r\n      auth: authSlice,\r\n    },\r\n    middleware: (getDefaultMiddleware) =>\r\n      getDefaultMiddleware().concat(apiSlice.middleware),\r\n    preloadedState: {\r\n      auth: {\r\n        isAuthenticated: true,\r\n        user: { id: 1, username: 'testuser', email: 'test@example.com', created_at: '', updated_at: '' },\r\n        token: 'test-token',\r\n        refreshToken: 'test-refresh-token',\r\n        isLoading: false,\r\n        error: null,\r\n      },\r\n    },\r\n  });\r\n};\r\n\r\n// Test wrapper component\r\nconst TestWrapper: React.FC<{ children: React.ReactNode }> = ({ children }) => {\r\n  const store = createTestStore();\r\n  return (\r\n    <Provider store={store}>\r\n      <BrowserRouter>\r\n        {children}\r\n      </BrowserRouter>\r\n    </Provider>\r\n  );\r\n};\r\n\r\ndescribe('EmailList Component', () => {\r\n  beforeEach(() => {\r\n    vi.clearAllMocks();\r\n  });\r\n\r\n  it('renders loading state initially', () => {\r\n    render(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    expect(screen.getByText('Loading Emails')).toBeInTheDocument();\r\n  });\r\n\r\n  it('displays inbox title when loaded', async () => {\r\n    render(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    // Wait for component to transition from loading to error state\r\n    // In test environment, API call will fail and show error\r\n    await waitFor(() => {\r\n      const heading = screen.getByRole('heading', { level: 2 });\r\n      expect(heading).toBeInTheDocument();\r\n      // Should show either \"Loading Emails\" or \"Error Loading Emails\"\r\n      expect(heading.textContent).toMatch(/(Loading Emails|Error Loading Emails)/);\r\n    }, { timeout: 3000 });\r\n  });\r\n\r\n  it('renders without crashing in error state', async () => {\r\n    render(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    // API will fail in test environment, should show error UI\r\n    await waitFor(() => {\r\n      // Should show error heading after loading fails\r\n      const heading = screen.getByRole('heading', { level: 2 });\r\n      expect(heading).toBeInTheDocument();\r\n      expect(heading.textContent).toMatch(/(Loading Emails|Error Loading Emails)/);\r\n    }, { timeout: 3000 });\r\n  });\r\n\r\n  it('renders component structure', async () => {\r\n    render(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    // Component should render with a heading even if API fails\r\n    await waitFor(() => {\r\n      const heading = screen.getByRole('heading', { level: 2 });\r\n      expect(heading).toBeInTheDocument();\r\n    }, { timeout: 3000 });\r\n  });\r\n\r\n  it('handles component lifecycle', async () => {\r\n    const { unmount } = render(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    await waitFor(() => {\r\n      expect(screen.getByRole('heading')).toBeInTheDocument();\r\n    });\r\n\r\n    // Should unmount without errors\r\n    unmount();\r\n  });\r\n});\r\n\r\ndescribe('Component Behavior', () => {\r\n  it('renders without throwing errors', async () => {\r\n    render(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    await waitFor(() => {\r\n      const heading = screen.getByRole('heading');\r\n      expect(heading).toBeInTheDocument();\r\n    });\r\n  });\r\n\r\n  it('maintains stable rendering', async () => {\r\n    const { rerender } = render(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    await waitFor(() => {\r\n      expect(screen.getByRole('heading', { level: 2 })).toBeInTheDocument();\r\n    }, { timeout: 3000 });\r\n\r\n    // Rerender should not cause errors\r\n    rerender(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    expect(screen.getByRole('heading', { level: 2 })).toBeInTheDocument();\r\n  });\r\n\r\n  it('handles API failure gracefully', async () => {\r\n    render(\r\n      <TestWrapper>\r\n        <EmailList />\r\n      </TestWrapper>\r\n    );\r\n\r\n    // Will fail to fetch in test environment, should show error state\r\n    await waitFor(() => {\r\n      const heading = screen.getByRole('heading', { level: 2 });\r\n      expect(heading).toBeInTheDocument();\r\n    }, { timeout: 3000 });\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\api.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\authSlice.test.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":66,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1668,1671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1668,1671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":97,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2862,2865],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2862,2865],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":107,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3228,3231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3228,3231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":119,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":119,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3559,3562],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3559,3562],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":153,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4662,4665],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4662,4665],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":172,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5319,5322],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5319,5322],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":203,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":203,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6330,6333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6330,6333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":206,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":206,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6466,6469],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6466,6469],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":220,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":220,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7006,7009],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7006,7009],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":224,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7184,7187],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7184,7187],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":232,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7498,7501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7498,7501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":236,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":236,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7676,7679],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7676,7679],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":252,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":252,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8227,8230],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8227,8230],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":256,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":256,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8405,8408],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8405,8408],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":270,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":270,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8963,8966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8963,8966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":273,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":273,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9098,9101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9098,9101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":16,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Tests for authentication slice\r\nimport { describe, it, expect, beforeEach, vi } from 'vitest';\r\nimport { configureStore } from '@reduxjs/toolkit';\r\nimport authReducer, { \r\n  loginStart, \r\n  loginSuccess, \r\n  loginFailure, \r\n  logout, \r\n  initializeAuth \r\n} from '@/store/authSlice';\r\nimport { tokenStorage } from '@/services/tokenStorage';\r\n\r\n// Mock the token storage\r\nvi.mock('@/services/tokenStorage', () => ({\r\n  tokenStorage: {\r\n    getTokens: vi.fn(),\r\n    setTokens: vi.fn(),\r\n    clearTokens: vi.fn(),\r\n    isTokenExpired: vi.fn(),\r\n    getStorageType: vi.fn(),\r\n  },\r\n}));\r\n\r\n// Mock the auth utils\r\nvi.mock('@/utils/authUtils', () => ({\r\n  getUserFromToken: vi.fn(() => ({\r\n    id: 1,\r\n    username: 'testuser',\r\n    email: 'testuser@example.com',\r\n  })),\r\n}));\r\n\r\nconst mockUser = {\r\n  id: 1,\r\n  username: 'testuser',\r\n  email: 'testuser@example.com',\r\n  created_at: '2024-01-01T00:00:00Z',\r\n  updated_at: '2024-01-01T00:00:00Z',\r\n};\r\n\r\nconst mockTokens = {\r\n  access_token: 'access_token_here',\r\n  refresh_token: 'refresh_token_here',\r\n  token_type: 'bearer',\r\n  expires_in: 3600,\r\n};\r\n\r\ndescribe('authSlice', () => {\r\n  let store: ReturnType<typeof configureStore>;\r\n\r\n  beforeEach(() => {\r\n    vi.clearAllMocks();\r\n    // Reset token storage mocks\r\n    vi.mocked(tokenStorage.getTokens).mockReturnValue(null);\r\n    vi.mocked(tokenStorage.isTokenExpired).mockReturnValue(true);\r\n    \r\n    store = configureStore({\r\n      reducer: {\r\n        auth: authReducer,\r\n      },\r\n    });\r\n  });\r\n\r\n  describe('initial state', () => {\r\n    it('should initialize with unauthenticated state when no valid tokens', () => {\r\n      const state = (store.getState() as any).auth;\r\n      expect(state.isAuthenticated).toBe(false);\r\n      expect(state.user).toBeNull();\r\n      expect(state.token).toBeNull();\r\n      expect(state.refreshToken).toBeNull();\r\n      expect(state.isLoading).toBe(false);\r\n      expect(state.error).toBeNull();\r\n    });\r\n\r\n    it('should initialize with authenticated state when valid tokens exist', () => {\r\n      // This test needs to be restructured because the module is already imported\r\n      // Instead, let's test the initialization behavior through the slice logic\r\n      const mockTokens = {\r\n        accessToken: 'valid_token',\r\n        refreshToken: 'valid_refresh_token',\r\n      };\r\n      \r\n      vi.mocked(tokenStorage.getTokens).mockReturnValue(mockTokens);\r\n      vi.mocked(tokenStorage.isTokenExpired).mockReturnValue(false);\r\n\r\n      // Test the loginSuccess action which simulates successful initialization\r\n      store.dispatch(loginSuccess({ \r\n        user: mockUser, \r\n        tokens: {\r\n          access_token: mockTokens.accessToken,\r\n          refresh_token: mockTokens.refreshToken,\r\n          token_type: 'bearer',\r\n          expires_in: 3600,\r\n        }\r\n      }));\r\n\r\n      const state = (store.getState() as any).auth;\r\n      expect(state.isAuthenticated).toBe(true);\r\n      expect(state.token).toBe(mockTokens.accessToken);\r\n      expect(state.refreshToken).toBe(mockTokens.refreshToken);\r\n    });\r\n  });\r\n\r\n  describe('synchronous actions', () => {\r\n    it('should handle loginStart', () => {\r\n      store.dispatch(loginStart());\r\n      const state = (store.getState() as any).auth;\r\n      \r\n      expect(state.isLoading).toBe(true);\r\n      expect(state.error).toBeNull();\r\n    });\r\n\r\n    it('should handle loginSuccess', () => {\r\n      store.dispatch(loginSuccess({ \r\n        user: mockUser, \r\n        tokens: mockTokens, \r\n        remember: true \r\n      }));\r\n      const state = (store.getState() as any).auth;\r\n      \r\n      expect(state.user).toEqual(mockUser);\r\n      expect(state.token).toBe(mockTokens.access_token);\r\n      expect(state.refreshToken).toBe(mockTokens.refresh_token);\r\n      expect(state.isAuthenticated).toBe(true);\r\n      expect(state.isLoading).toBe(false);\r\n      expect(state.error).toBeNull();\r\n      \r\n      // Should persist tokens\r\n      expect(tokenStorage.setTokens).toHaveBeenCalledWith(\r\n        mockTokens.access_token,\r\n        mockTokens.refresh_token,\r\n        true\r\n      );\r\n    });\r\n\r\n    it('should handle loginSuccess without remember flag', () => {\r\n      store.dispatch(loginSuccess({ \r\n        user: mockUser, \r\n        tokens: mockTokens \r\n      }));\r\n      \r\n      // Should default remember to false\r\n      expect(tokenStorage.setTokens).toHaveBeenCalledWith(\r\n        mockTokens.access_token,\r\n        mockTokens.refresh_token,\r\n        false\r\n      );\r\n    });\r\n\r\n    it('should handle loginFailure', () => {\r\n      const errorMessage = 'Invalid credentials';\r\n      store.dispatch(loginFailure(errorMessage));\r\n      const state = (store.getState() as any).auth;\r\n      \r\n      expect(state.user).toBeNull();\r\n      expect(state.token).toBeNull();\r\n      expect(state.refreshToken).toBeNull();\r\n      expect(state.isAuthenticated).toBe(false);\r\n      expect(state.isLoading).toBe(false);\r\n      expect(state.error).toBe(errorMessage);\r\n      \r\n      // Should clear tokens\r\n      expect(tokenStorage.clearTokens).toHaveBeenCalled();\r\n    });\r\n\r\n    it('should handle logout', () => {\r\n      // First set up authenticated state\r\n      store.dispatch(loginSuccess({ user: mockUser, tokens: mockTokens }));\r\n      \r\n      // Then logout\r\n      store.dispatch(logout());\r\n      const state = (store.getState() as any).auth;\r\n      \r\n      expect(state.user).toBeNull();\r\n      expect(state.token).toBeNull();\r\n      expect(state.refreshToken).toBeNull();\r\n      expect(state.isAuthenticated).toBe(false);\r\n      expect(state.isLoading).toBe(false);\r\n      expect(state.error).toBeNull();\r\n      \r\n      // Should clear tokens\r\n      expect(tokenStorage.clearTokens).toHaveBeenCalled();\r\n    });\r\n  });\r\n\r\n  describe('initializeAuth async thunk', () => {\r\n    beforeEach(() => {\r\n      global.fetch = vi.fn();\r\n    });\r\n\r\n    it('should handle successful initialization with valid tokens', async () => {\r\n      vi.mocked(tokenStorage.getTokens).mockReturnValue({\r\n        accessToken: 'valid_token',\r\n        refreshToken: 'valid_refresh_token',\r\n      });\r\n      vi.mocked(tokenStorage.isTokenExpired).mockReturnValue(false);\r\n      \r\n      vi.mocked(global.fetch).mockResolvedValue({\r\n        ok: true,\r\n        json: () => Promise.resolve(mockUser),\r\n      } as Response);\r\n\r\n      const result = await (store.dispatch as any)(initializeAuth());\r\n      expect(result.type).toBe('auth/initialize/fulfilled');\r\n      \r\n      const state = (store.getState() as any).auth;\r\n      expect(state.isAuthenticated).toBe(true);\r\n      expect(state.user).toEqual(mockUser);\r\n      expect(state.isLoading).toBe(false);\r\n      expect(state.error).toBeNull();\r\n    });\r\n\r\n    it('should handle initialization with expired tokens', async () => {\r\n      vi.mocked(tokenStorage.getTokens).mockReturnValue({\r\n        accessToken: 'expired_token',\r\n        refreshToken: 'refresh_token',\r\n      });\r\n      vi.mocked(tokenStorage.isTokenExpired).mockReturnValue(true);\r\n\r\n      const result = await (store.dispatch as any)(initializeAuth());\r\n      expect(result.type).toBe('auth/initialize/fulfilled');\r\n      expect(result.payload).toBeNull();\r\n      \r\n      const state = (store.getState() as any).auth;\r\n      expect(state.isAuthenticated).toBe(false);\r\n      expect(tokenStorage.clearTokens).toHaveBeenCalled();\r\n    });\r\n\r\n    it('should handle initialization with no tokens', async () => {\r\n      vi.mocked(tokenStorage.getTokens).mockReturnValue(null);\r\n\r\n      const result = await (store.dispatch as any)(initializeAuth());\r\n      expect(result.type).toBe('auth/initialize/fulfilled');\r\n      expect(result.payload).toBeNull();\r\n      \r\n      const state = (store.getState() as any).auth;\r\n      expect(state.isAuthenticated).toBe(false);\r\n    });\r\n\r\n    it('should handle initialization with invalid server response', async () => {\r\n      vi.mocked(tokenStorage.getTokens).mockReturnValue({\r\n        accessToken: 'valid_token',\r\n        refreshToken: 'valid_refresh_token',\r\n      });\r\n      vi.mocked(tokenStorage.isTokenExpired).mockReturnValue(false);\r\n      \r\n      vi.mocked(global.fetch).mockResolvedValue({\r\n        ok: false,\r\n        status: 401,\r\n      } as Response);\r\n\r\n      const result = await (store.dispatch as any)(initializeAuth());\r\n      expect(result.type).toBe('auth/initialize/fulfilled');\r\n      expect(result.payload).toBeNull();\r\n      \r\n      const state = (store.getState() as any).auth;\r\n      expect(state.isAuthenticated).toBe(false);\r\n      expect(tokenStorage.clearTokens).toHaveBeenCalled();\r\n    });\r\n\r\n    it('should handle initialization network error', async () => {\r\n      vi.mocked(tokenStorage.getTokens).mockReturnValue({\r\n        accessToken: 'valid_token',\r\n        refreshToken: 'valid_refresh_token',\r\n      });\r\n      vi.mocked(tokenStorage.isTokenExpired).mockReturnValue(false);\r\n      \r\n      vi.mocked(global.fetch).mockRejectedValue(new Error('Network error'));\r\n\r\n      const result = await (store.dispatch as any)(initializeAuth());\r\n      expect(result.type).toBe('auth/initialize/rejected');\r\n      \r\n      const state = (store.getState() as any).auth;\r\n      expect(state.isAuthenticated).toBe(false);\r\n      expect(state.error).toBe('Session initialization failed');\r\n      expect(tokenStorage.clearTokens).toHaveBeenCalled();\r\n    });\r\n  });\r\n});","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\config.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\integration.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'init' is defined but never used.","line":32,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":32,"endColumn":68}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Integration tests for backend API connectivity\r\nimport { describe, it, expect, beforeAll, afterAll, vi } from 'vitest';\r\n\r\nconst BACKEND_URL = 'http://localhost:8000';\r\nconst API_TIMEOUT = 5000;\r\n\r\n// Helper function to check if backend is available\r\nasync function isBackendAvailable(): Promise<boolean> {\r\n  try {\r\n    const response = await fetch(`${BACKEND_URL}/health`, {\r\n      method: 'GET',\r\n      signal: AbortSignal.timeout(API_TIMEOUT),\r\n    });\r\n    return response.ok;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\ndescribe('Backend API Integration Tests', () => {\r\n  let backendAvailable = false;\r\n  let originalFetch: typeof global.fetch;\r\n\r\n  beforeAll(async () => {\r\n    originalFetch = global.fetch;\r\n    backendAvailable = await isBackendAvailable();\r\n    \r\n    if (!backendAvailable) {\r\n      console.warn('ΓÜá∩╕Å  Backend not available - using mocked responses');\r\n      \r\n      // Mock fetch to simulate backend responses\r\n      global.fetch = vi.fn(async (url: string | URL | Request, init?: RequestInit) => {\r\n        const urlString = typeof url === 'string' ? url : url.toString();\r\n        const path = urlString.replace(BACKEND_URL, '');\r\n        \r\n        if (path === '/health') {\r\n          return new Response(JSON.stringify({\r\n            status: 'healthy',\r\n            service: 'email-helper-backend',\r\n            version: '1.0.0'\r\n          }), { status: 200, headers: { 'Content-Type': 'application/json' } });\r\n        }\r\n        \r\n        if (path === '/auth/register' || path === '/auth/login') {\r\n          return new Response(JSON.stringify({ detail: 'Validation error' }), {\r\n            status: 422,\r\n            headers: { 'Content-Type': 'application/json' }\r\n          });\r\n        }\r\n        \r\n        if (path === '/api/emails' || path === '/api/tasks') {\r\n          return new Response(JSON.stringify({ detail: 'Not authenticated' }), {\r\n            status: 401,\r\n            headers: { 'Content-Type': 'application/json' }\r\n          });\r\n        }\r\n        \r\n        if (path === '/api/ai/classify') {\r\n          return new Response(JSON.stringify({ detail: 'Not authenticated' }), {\r\n            status: 401,\r\n            headers: { 'Content-Type': 'application/json' }\r\n          });\r\n        }\r\n        \r\n        if (path === '/docs' || path === '/redoc') {\r\n          return new Response('<html><body>API Documentation</body></html>', {\r\n            status: 200,\r\n            headers: { 'Content-Type': 'text/html' }\r\n          });\r\n        }\r\n        \r\n        return new Response('Not Found', { status: 404 });\r\n      }) as typeof global.fetch;\r\n    } else {\r\n      console.log('Γ£à Backend is available - running integration tests against real server');\r\n    }\r\n  });\r\n\r\n  afterAll(() => {\r\n    if (!backendAvailable) {\r\n      global.fetch = originalFetch;\r\n    }\r\n  });\r\n\r\n  describe('Health Check (T1-T4 Backend Status)', () => {\r\n    it('should connect to backend health endpoint', async () => {\r\n      const response = await fetch(`${BACKEND_URL}/health`);\r\n      expect(response.ok).toBe(true);\r\n\r\n      const data = await response.json();\r\n      expect(data).toHaveProperty('status');\r\n      expect(data).toHaveProperty('service');\r\n      expect(data).toHaveProperty('version');\r\n      expect(data.status).toBe('healthy');\r\n    });\r\n  });\r\n\r\n  describe('Authentication API (T1)', () => {\r\n    it('should have auth endpoints available', async () => {\r\n      // Test registration endpoint exists (should return 422 for empty body)\r\n      const registerResponse = await fetch(`${BACKEND_URL}/auth/register`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({}),\r\n      });\r\n      expect([400, 422]).toContain(registerResponse.status);\r\n\r\n      // Test login endpoint exists (should return 422 for empty body)\r\n      const loginResponse = await fetch(`${BACKEND_URL}/auth/login`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({}),\r\n      });\r\n      expect([400, 422]).toContain(loginResponse.status);\r\n    });\r\n  });\r\n\r\n  describe('Email API (T2)', () => {\r\n    it('should have email endpoints available', async () => {\r\n      // Test emails endpoint exists (should return 403/401 without auth)\r\n      const emailsResponse = await fetch(`${BACKEND_URL}/api/emails`);\r\n      expect([401, 403]).toContain(emailsResponse.status);\r\n    });\r\n  });\r\n\r\n  describe('AI Processing API (T3)', () => {\r\n    it('should have AI endpoints available', async () => {\r\n      // Test AI classify endpoint exists (should return 403/401 without auth)\r\n      const classifyResponse = await fetch(`${BACKEND_URL}/api/ai/classify`, {\r\n        method: 'POST',\r\n        headers: { 'Content-Type': 'application/json' },\r\n        body: JSON.stringify({}),\r\n      });\r\n      expect([401, 403, 422]).toContain(classifyResponse.status);\r\n    });\r\n  });\r\n\r\n  describe('Task Management API (T4)', () => {\r\n    it('should have task endpoints available', async () => {\r\n      // Test tasks endpoint exists (should return 403/401 without auth)\r\n      const tasksResponse = await fetch(`${BACKEND_URL}/api/tasks`);\r\n      expect([401, 403]).toContain(tasksResponse.status);\r\n    });\r\n  });\r\n\r\n  describe('API Documentation', () => {\r\n    it('should have OpenAPI docs available', async () => {\r\n      const docsResponse = await fetch(`${BACKEND_URL}/docs`);\r\n      expect(docsResponse.ok).toBe(true);\r\n\r\n      const redocResponse = await fetch(`${BACKEND_URL}/redoc`);\r\n      expect(redocResponse.ok).toBe(true);\r\n    });\r\n  });\r\n});\r\n\r\n// Export helper for use in other tests\r\nexport { isBackendAvailable, BACKEND_URL };","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\routes.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\test\\tokenStorage.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\types\\ai.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\types\\api.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\types\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\types\\email.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\types\\task.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\utils\\authUtils.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'error' is defined but never used.","line":33,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":17}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Authentication utility functions\r\nimport { isAfter, addMinutes } from 'date-fns';\r\nimport type { User } from '@/types/auth';\r\n\r\n/**\r\n * Extract user information from JWT token payload\r\n */\r\nexport const getUserFromToken = (token: string): Partial<User> | null => {\r\n  try {\r\n    const payload = JSON.parse(atob(token.split('.')[1]));\r\n    \r\n    return {\r\n      id: payload.user_id,\r\n      username: payload.sub,\r\n      email: `${payload.sub}@example.com`, // Fallback email\r\n    };\r\n  } catch (error) {\r\n    console.warn('Failed to extract user from token:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Get token expiration date\r\n */\r\nexport const getTokenExpiration = (token: string): Date | null => {\r\n  try {\r\n    const payload = JSON.parse(atob(token.split('.')[1]));\r\n    if (payload.exp) {\r\n      return new Date(payload.exp * 1000);\r\n    }\r\n    return null;\r\n  } catch (error) {\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Check if token will expire soon (within specified minutes)\r\n */\r\nexport const willTokenExpireSoon = (token: string, withinMinutes: number = 5): boolean => {\r\n  const expiration = getTokenExpiration(token);\r\n  if (!expiration) return true;\r\n  \r\n  const soon = addMinutes(new Date(), withinMinutes);\r\n  return isAfter(soon, expiration);\r\n};\r\n\r\n/**\r\n * Validate email format\r\n */\r\nexport const isValidEmail = (email: string): boolean => {\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  return emailRegex.test(email);\r\n};\r\n\r\n/**\r\n * Validate password strength\r\n */\r\nexport const validatePassword = (password: string): { isValid: boolean; errors: string[] } => {\r\n  const errors: string[] = [];\r\n  \r\n  if (password.length < 8) {\r\n    errors.push('Password must be at least 8 characters long');\r\n  }\r\n  \r\n  if (!/[A-Z]/.test(password)) {\r\n    errors.push('Password must contain at least one uppercase letter');\r\n  }\r\n  \r\n  if (!/[a-z]/.test(password)) {\r\n    errors.push('Password must contain at least one lowercase letter');\r\n  }\r\n  \r\n  if (!/\\d/.test(password)) {\r\n    errors.push('Password must contain at least one number');\r\n  }\r\n  \r\n  return {\r\n    isValid: errors.length === 0,\r\n    errors,\r\n  };\r\n};\r\n\r\n/**\r\n * Create user-friendly error messages from API errors\r\n */\r\nexport const getAuthErrorMessage = (error: unknown): string => {\r\n  if (typeof error === 'string') {\r\n    return error;\r\n  }\r\n  \r\n  if (error && typeof error === 'object') {\r\n    const apiError = error as { data?: { message?: string; detail?: string } };\r\n    if (apiError.data?.message) {\r\n      return apiError.data.message;\r\n    }\r\n    if (apiError.data?.detail) {\r\n      return apiError.data.detail;\r\n    }\r\n  }\r\n  \r\n  return 'An unexpected error occurred. Please try again.';\r\n};\r\n\r\n/**\r\n * Get redirect path from location state or default\r\n */\r\nexport const getRedirectPath = (locationState: unknown, defaultPath: string = '/'): string => {\r\n  if (locationState && typeof locationState === 'object') {\r\n    const state = locationState as { from?: { pathname?: string } };\r\n    return state.from?.pathname || defaultPath;\r\n  }\r\n  return defaultPath;\r\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\utils\\emailSanitization.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\utils\\emailUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\src\\utils\\taskUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\api-integration.spec.ts","messages":[{"ruleId":"prefer-const","severity":2,"message":"'queryParams' is never reassigned. Use 'const' instead.","line":69,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":69,"endColumn":46,"fix":{"range":[2325,2370],"text":"const queryParams: Record<string, string> = {};"}},{"ruleId":"prefer-const","severity":2,"message":"'queryParams' is never reassigned. Use 'const' instead.","line":95,"column":11,"nodeType":"Identifier","messageId":"useConst","endLine":95,"endColumn":46,"fix":{"range":[3236,3281],"text":"const queryParams: Record<string, string> = {};"}},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":189,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6530,6533],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6530,6533],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":254,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8696,8699],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8696,8699],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'requestBody' is assigned a value but never used.","line":317,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":317,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":317,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":317,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11098,11101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11098,11101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'authHeader' is assigned a value but never used.","line":597,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":597,"endColumn":21}],"suppressedMessages":[],"errorCount":7,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":2,"fixableWarningCount":0,"source":"/**\r\n * E2E Tests for Frontend-to-Backend API Integration\r\n * \r\n * Verifies that frontend correctly calls backend APIs and handles responses.\r\n * Uses Playwright route interception to verify request payloads and response handling.\r\n * \r\n * Tests:\r\n * - Email list loads from /api/emails\r\n * - Email detail fetches from /api/emails/:id\r\n * - Classification triggers /api/ai/classify\r\n * - Task creation posts to /api/tasks\r\n * - Bulk operations hit /api/emails/batch\r\n * - Error responses handled gracefully (404, 500, timeout)\r\n */\r\n\r\nimport { test, expect } from './fixtures/test-setup';\r\nimport type { Route } from '@playwright/test';\r\n\r\ntest.describe('Frontend-to-Backend API Integration', () => {\r\n  \r\n  test.describe('Email List API Integration', () => {\r\n    test('should call GET /api/emails with correct query parameters', async ({ page }) => {\r\n      let requestCaptured = false;\r\n      let requestUrl = '';\r\n      let requestMethod = '';\r\n      \r\n      // Intercept the API call\r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        const request = route.request();\r\n        requestCaptured = true;\r\n        requestUrl = request.url();\r\n        requestMethod = request.method();\r\n        \r\n        // Respond with mock data\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({\r\n            emails: [\r\n              {\r\n                id: '1',\r\n                subject: 'Test Email 1',\r\n                sender: 'test@example.com',\r\n                received: new Date().toISOString(),\r\n                body: 'Test body',\r\n                category: 'actionable'\r\n              }\r\n            ],\r\n            total: 1\r\n          })\r\n        });\r\n      });\r\n      \r\n      // Navigate to emails page\r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify API was called\r\n      expect(requestCaptured).toBe(true);\r\n      expect(requestMethod).toBe('GET');\r\n      expect(requestUrl).toContain('/api/emails');\r\n      \r\n      // Verify UI updates with data\r\n      await expect(page.locator('text=Test Email 1')).toBeVisible({ timeout: 5000 });\r\n    });\r\n    \r\n    test('should handle pagination parameters correctly', async ({ page }) => {\r\n      let apiCalled = false;\r\n      let queryParams: Record<string, string> = {};\r\n      \r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        apiCalled = true;\r\n        const url = new URL(route.request().url());\r\n        url.searchParams.forEach((value, key) => {\r\n          queryParams[key] = value;\r\n        });\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ emails: [], total: 0 })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails?page=2&limit=20');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify API was called with URL parameters\r\n      expect(apiCalled).toBe(true);\r\n      // Note: Implementation may use different pagination approaches\r\n      // Just verify the API was called successfully\r\n    });\r\n    \r\n    test('should handle source filter parameter', async ({ page }) => {\r\n      let queryParams: Record<string, string> = {};\r\n      \r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        const url = new URL(route.request().url());\r\n        url.searchParams.forEach((value, key) => {\r\n          queryParams[key] = value;\r\n        });\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ emails: [], total: 0 })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(1000);\r\n      \r\n      // Click source filter if available\r\n      const filterButton = page.locator('button:has-text(\"Database\"), button:has-text(\"Outlook\")').first();\r\n      if (await filterButton.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await filterButton.click();\r\n        await page.waitForTimeout(1000);\r\n      }\r\n      \r\n      // Verify source parameter might be sent (optional based on UI)\r\n      // This validates the pattern even if specific implementation varies\r\n      expect(queryParams).toBeDefined();\r\n    });\r\n  });\r\n  \r\n  test.describe('Email Detail API Integration', () => {\r\n    test('should call GET /api/emails/:id for email detail', async ({ page }) => {\r\n      let detailRequestCaptured = false;\r\n      let emailId = '';\r\n      \r\n      // Mock list endpoint\r\n      await page.route('**/api/emails?*', async (route: Route) => {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({\r\n            emails: [\r\n              {\r\n                id: 'email-123',\r\n                subject: 'Clickable Email',\r\n                sender: 'sender@example.com',\r\n                received: new Date().toISOString(),\r\n                body: 'Email body'\r\n              }\r\n            ]\r\n          })\r\n        });\r\n      });\r\n      \r\n      // Mock detail endpoint\r\n      await page.route('**/api/emails/email-123', async (route: Route) => {\r\n        detailRequestCaptured = true;\r\n        emailId = route.request().url().split('/').pop() || '';\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({\r\n            id: 'email-123',\r\n            subject: 'Detailed Email',\r\n            sender: 'sender@example.com',\r\n            received: new Date().toISOString(),\r\n            body: 'Detailed email body',\r\n            category: 'actionable'\r\n          })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Click first email to view details\r\n      const emailItem = page.locator('[data-testid=\"email-item\"], .email-item').first();\r\n      if (await emailItem.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await emailItem.click();\r\n        await page.waitForTimeout(1000);\r\n        \r\n        // Verify detail API was called if implemented\r\n        if (detailRequestCaptured) {\r\n          expect(emailId).toBe('email-123');\r\n        }\r\n      }\r\n    });\r\n  });\r\n  \r\n  test.describe('AI Classification API Integration', () => {\r\n    test('should call POST /api/ai/classify with email data', async ({ page }) => {\r\n      let classifyRequestCaptured = false;\r\n      let requestBody: any = null;\r\n      let requestMethod = '';\r\n      \r\n      // Mock emails list\r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        if (route.request().method() === 'GET') {\r\n          await route.fulfill({\r\n            status: 200,\r\n            contentType: 'application/json',\r\n            body: JSON.stringify({\r\n              emails: [{\r\n                id: 'test-email',\r\n                subject: 'Test Classification',\r\n                sender: 'test@example.com',\r\n                received: new Date().toISOString(),\r\n                body: 'Test body'\r\n              }]\r\n            })\r\n          });\r\n        } else {\r\n          await route.continue();\r\n        }\r\n      });\r\n      \r\n      // Mock classification endpoint\r\n      await page.route('**/api/ai/classify*', async (route: Route) => {\r\n        classifyRequestCaptured = true;\r\n        requestMethod = route.request().method();\r\n        const postData = route.request().postData();\r\n        if (postData) {\r\n          requestBody = JSON.parse(postData);\r\n        }\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({\r\n            category: 'actionable',\r\n            confidence: 0.95,\r\n            reasoning: 'Contains action items'\r\n          })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Trigger classification\r\n      const classifyButton = page.locator('button:has-text(\"Classify\"), button:has-text(\"Process\")').first();\r\n      if (await classifyButton.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await classifyButton.click();\r\n        await page.waitForTimeout(2000);\r\n        \r\n        // Verify API was called\r\n        if (classifyRequestCaptured) {\r\n          expect(requestMethod).toBe('POST');\r\n          expect(requestBody).toBeTruthy();\r\n        }\r\n      }\r\n    });\r\n  });\r\n  \r\n  test.describe('Task Creation API Integration', () => {\r\n    test('should call POST /api/tasks with task data', async ({ page }) => {\r\n      let taskRequestCaptured = false;\r\n      let requestBody: any = null;\r\n      \r\n      // Mock task creation endpoint\r\n      await page.route('**/api/tasks', async (route: Route) => {\r\n        if (route.request().method() === 'POST') {\r\n          taskRequestCaptured = true;\r\n          const postData = route.request().postData();\r\n          if (postData) {\r\n            requestBody = JSON.parse(postData);\r\n          }\r\n          \r\n          await route.fulfill({\r\n            status: 201,\r\n            contentType: 'application/json',\r\n            body: JSON.stringify({\r\n              id: 'task-123',\r\n              title: requestBody?.title || 'New Task',\r\n              status: 'pending',\r\n              created: new Date().toISOString()\r\n            })\r\n          });\r\n        } else if (route.request().method() === 'GET') {\r\n          await route.fulfill({\r\n            status: 200,\r\n            contentType: 'application/json',\r\n            body: JSON.stringify({ tasks: [], total: 0 })\r\n          });\r\n        } else {\r\n          await route.continue();\r\n        }\r\n      });\r\n      \r\n      await page.goto('/tasks');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Try to create a task\r\n      const createButton = page.locator('button:has-text(\"Create\"), button:has-text(\"New Task\"), button:has-text(\"Add\")').first();\r\n      if (await createButton.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await createButton.click();\r\n        await page.waitForTimeout(1000);\r\n        \r\n        // Fill task form if it exists\r\n        const titleInput = page.locator('input[placeholder*=\"title\" i], input[name=\"title\"]').first();\r\n        if (await titleInput.isVisible({ timeout: 2000 }).catch(() => false)) {\r\n          await titleInput.fill('Test Task');\r\n          \r\n          const submitButton = page.locator('button:has-text(\"Save\"), button:has-text(\"Create\"), button[type=\"submit\"]').first();\r\n          await submitButton.click();\r\n          await page.waitForTimeout(2000);\r\n          \r\n          // Verify API was called\r\n          if (taskRequestCaptured) {\r\n            expect(requestBody).toBeTruthy();\r\n            expect(requestBody.title).toBe('Test Task');\r\n          }\r\n        }\r\n      }\r\n    });\r\n  });\r\n  \r\n  test.describe('Bulk Operations API Integration', () => {\r\n    test('should call POST /api/emails/batch or bulk endpoint', async ({ page }) => {\r\n      let bulkRequestCaptured = false;\r\n      let requestBody: any = null;\r\n      let requestUrl = '';\r\n      \r\n      // Mock emails list\r\n      await page.route('**/api/emails?*', async (route: Route) => {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({\r\n            emails: [\r\n              { id: '1', subject: 'Email 1', sender: 'test@example.com' },\r\n              { id: '2', subject: 'Email 2', sender: 'test@example.com' }\r\n            ]\r\n          })\r\n        });\r\n      });\r\n      \r\n      // Mock bulk operations\r\n      await page.route('**/api/emails/**bulk*', async (route: Route) => {\r\n        bulkRequestCaptured = true;\r\n        requestUrl = route.request().url();\r\n        const postData = route.request().postData();\r\n        if (postData) {\r\n          requestBody = JSON.parse(postData);\r\n        }\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ success: true, processed: 2 })\r\n        });\r\n      });\r\n      \r\n      await page.route('**/api/emails/batch*', async (route: Route) => {\r\n        bulkRequestCaptured = true;\r\n        requestUrl = route.request().url();\r\n        const postData = route.request().postData();\r\n        if (postData) {\r\n          requestBody = JSON.parse(postData);\r\n        }\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ success: true, processed: 2 })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Look for bulk action buttons\r\n      const bulkButton = page.locator(\r\n        'button:has-text(\"Bulk\"), button:has-text(\"Apply All\"), button:has-text(\"Process All\")'\r\n      ).first();\r\n      \r\n      if (await bulkButton.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await bulkButton.click();\r\n        await page.waitForTimeout(2000);\r\n        \r\n        if (bulkRequestCaptured) {\r\n          expect(requestUrl).toMatch(/bulk|batch/i);\r\n        }\r\n      }\r\n    });\r\n  });\r\n  \r\n  test.describe('Error Response Handling', () => {\r\n    test('should handle 404 Not Found gracefully', async ({ page }) => {\r\n      await page.route('**/api/emails/nonexistent-id', async (route: Route) => {\r\n        await route.fulfill({\r\n          status: 404,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ error: 'Email not found' })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails/nonexistent-id');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify app doesn't crash - page loads without console errors\r\n      const pageTitle = await page.title();\r\n      expect(pageTitle).toBeTruthy(); // Page loaded successfully\r\n      \r\n      // Error message or empty state should be visible (optional check)\r\n      const hasContent = await page.locator('body').textContent();\r\n      expect(hasContent).toBeTruthy(); // Some content rendered\r\n    });\r\n    \r\n    test('should handle 500 Internal Server Error gracefully', async ({ page }) => {\r\n      let retryCount = 0;\r\n      \r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        retryCount++;\r\n        \r\n        await route.fulfill({\r\n          status: 500,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ error: 'Internal server error' })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(3000);\r\n      \r\n      // Verify app doesn't crash - page loads\r\n      expect(retryCount).toBeGreaterThan(0); // API was called\r\n      const pageTitle = await page.title();\r\n      expect(pageTitle).toBeTruthy(); // Page loaded without crashing\r\n    });\r\n    \r\n    test('should handle network timeout gracefully', async ({ page }) => {\r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        // Simulate timeout by delaying response\r\n        await new Promise(resolve => setTimeout(resolve, 10000));\r\n        await route.abort('timedout');\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(5000);\r\n      \r\n      // Verify loading state or error message\r\n      const loadingOrError = await page.locator('text=/loading|error|timeout|failed/i').isVisible({ timeout: 3000 }).catch(() => false);\r\n      // Either loading indicator should be visible or error shown\r\n      expect(loadingOrError || true).toBeTruthy(); // Graceful handling means no crash\r\n    });\r\n    \r\n    test('should handle 401 Unauthorized correctly', async ({ page }) => {\r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        await route.fulfill({\r\n          status: 401,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ error: 'Unauthorized' })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Should show auth error or redirect to login\r\n      const authError = await page.locator('text=/unauthorized|login|authentication/i').isVisible({ timeout: 5000 }).catch(() => false);\r\n      expect(authError || page.url().includes('login')).toBeTruthy();\r\n    });\r\n    \r\n    test('should retry failed requests with proper backoff', async ({ page }) => {\r\n      let requestCount = 0;\r\n      \r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        requestCount++;\r\n        \r\n        if (requestCount === 1) {\r\n          // First request fails\r\n          await route.fulfill({\r\n            status: 503,\r\n            contentType: 'application/json',\r\n            body: JSON.stringify({ error: 'Service unavailable' })\r\n          });\r\n        } else {\r\n          // Subsequent requests succeed\r\n          await route.fulfill({\r\n            status: 200,\r\n            contentType: 'application/json',\r\n            body: JSON.stringify({ emails: [], total: 0 })\r\n          });\r\n        }\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(5000);\r\n      \r\n      // If retry logic exists, we should see multiple requests\r\n      // At minimum, verify the app doesn't crash\r\n      expect(requestCount).toBeGreaterThanOrEqual(1);\r\n    });\r\n  });\r\n  \r\n  test.describe('Response Data Validation', () => {\r\n    test('should process valid email list response correctly', async ({ page }) => {\r\n      const mockResponse = {\r\n        emails: [\r\n          {\r\n            id: 'email-1',\r\n            subject: 'Validated Email',\r\n            sender: 'sender@example.com',\r\n            received: new Date().toISOString(),\r\n            body: 'Email body',\r\n            category: 'actionable'\r\n          }\r\n        ],\r\n        total: 1\r\n      };\r\n      \r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify(mockResponse)\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify data is displayed correctly\r\n      await expect(page.locator('text=Validated Email')).toBeVisible({ timeout: 5000 });\r\n      await expect(page.locator('text=sender@example.com')).toBeVisible({ timeout: 5000 });\r\n    });\r\n    \r\n    test('should handle malformed JSON response gracefully', async ({ page }) => {\r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: 'invalid json {'\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Should show error, not crash\r\n      const errorVisible = await page.locator('text=/error|failed/i').isVisible({ timeout: 5000 }).catch(() => false);\r\n      expect(errorVisible || true).toBeTruthy(); // Graceful handling\r\n    });\r\n    \r\n    test('should handle empty response arrays correctly', async ({ page }) => {\r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ emails: [], total: 0 })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Should show empty state, not crash\r\n      const emptyState = await page.locator('text=/no emails|empty|no results/i').isVisible({ timeout: 5000 }).catch(() => false);\r\n      expect(emptyState || true).toBeTruthy(); // Graceful handling\r\n    });\r\n  });\r\n  \r\n  test.describe('Request Payload Validation', () => {\r\n    test('should send correct Content-Type headers', async ({ page }) => {\r\n      let contentType = '';\r\n      \r\n      await page.route('**/api/ai/classify*', async (route: Route) => {\r\n        contentType = (await route.request().headerValue('content-type')) || '';\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ category: 'actionable' })\r\n        });\r\n      });\r\n      \r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ emails: [{ id: '1', subject: 'Test' }] })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      const classifyButton = page.locator('button:has-text(\"Classify\"), button:has-text(\"Process\")').first();\r\n      if (await classifyButton.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await classifyButton.click();\r\n        await page.waitForTimeout(2000);\r\n        \r\n        if (contentType) {\r\n          expect(contentType).toContain('application/json');\r\n        }\r\n      }\r\n    });\r\n    \r\n    test('should include authentication headers if required', async ({ page }) => {\r\n      let authHeader = '';\r\n      \r\n      await page.route('**/api/emails*', async (route: Route) => {\r\n        authHeader = (await route.request().headerValue('authorization')) || '';\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ emails: [], total: 0 })\r\n        });\r\n      });\r\n      \r\n      await page.goto('/emails');\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // If auth is implemented, verify header is present\r\n      // Otherwise just verify request was made\r\n      expect(true).toBeTruthy(); // Test passes if no crash\r\n    });\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\button-test.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\critical-user-flows.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":395,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":395,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15011,15014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15011,15014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockEmailAPI' is defined but never used.","line":516,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":516,"endColumn":17}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Comprehensive E2E Tests for Critical User Flows\r\n * \r\n * Tests the top 5 user journeys with happy path and error scenarios:\r\n * 1. Login ΓåÆ Fetch Emails ΓåÆ Classify ΓåÆ View Results\r\n * 2. Email ΓåÆ Create Task ΓåÆ Update Task ΓåÆ Complete Task\r\n * 3. Bulk Process ΓåÆ Review Categories ΓåÆ Edit Classification\r\n * 4. Settings ΓåÆ Update Config ΓåÆ Verify Changes Applied\r\n * 5. Error Recovery ΓåÆ Retry Failed Operations\r\n */\r\n\r\nimport { test, expect } from './fixtures/test-setup';\r\n\r\ntest.describe('Critical User Flow 1: Email Retrieval and Classification', () => {\r\n  test('happy path: should retrieve emails, classify, and view results', async ({ \r\n    page, \r\n    mockEmails, \r\n    mockEmailAPI, \r\n    mockAIAPI,\r\n    navigateToEmails \r\n  }) => {\r\n    // Setup mocks\r\n    await mockEmailAPI(page, mockEmails);\r\n    await mockAIAPI(page);\r\n    \r\n    // Navigate to emails page\r\n    await navigateToEmails(page);\r\n    \r\n    // Verify emails are loaded\r\n    await expect(page.locator('[data-testid=\"email-list\"], .email-list, [class*=\"email\"]')).toBeVisible({ timeout: 10000 });\r\n    \r\n    // Count emails displayed\r\n    const emailCount = await page.locator('[data-testid=\"email-item\"], .email-item, [class*=\"email-item\"]').count();\r\n    expect(emailCount).toBeGreaterThan(0);\r\n    \r\n    // Verify email content is visible\r\n    const hasEmailContent = await page.locator('text=/Test Email|Subject:|From:/').count();\r\n    expect(hasEmailContent).toBeGreaterThan(0);\r\n    \r\n    // Select first email\r\n    const firstEmail = page.locator('[data-testid=\"email-item\"], .email-item').first();\r\n    await firstEmail.click();\r\n    await page.waitForTimeout(1000);\r\n    \r\n    // Trigger classification\r\n    const classifyButton = page.locator(\r\n      'button:has-text(\"Classify\"), button:has-text(\"Process\"), button:has-text(\"Categorize\")'\r\n    ).first();\r\n    \r\n    if (await classifyButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      // Track API call\r\n      const classifyPromise = page.waitForResponse(resp => \r\n        resp.url().includes('/api/ai/classify') && resp.status() === 200\r\n      );\r\n      \r\n      await classifyButton.click();\r\n      \r\n      // Verify classification API was called\r\n      const response = await classifyPromise;\r\n      const data = await response.json();\r\n      expect(data.category).toBeDefined();\r\n      expect(data.confidence).toBeGreaterThan(0);\r\n      \r\n      // Wait for classification result to display\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify classification result is shown\r\n      const hasCategory = await page.locator(\r\n        'text=/required_personal_action|optional_fyi|team_discussion|task_delegation/i'\r\n      ).count();\r\n      expect(hasCategory).toBeGreaterThan(0);\r\n    }\r\n  });\r\n  \r\n  test('error path: should handle classification failure gracefully', async ({ \r\n    page, \r\n    mockEmails, \r\n    mockEmailAPI,\r\n    navigateToEmails \r\n  }) => {\r\n    await mockEmailAPI(page, mockEmails);\r\n    \r\n    // Mock classification failure\r\n    await page.route('**/api/ai/classify*', async (route) => {\r\n      await route.fulfill({\r\n        status: 500,\r\n        contentType: 'application/json',\r\n        body: JSON.stringify({ error: 'AI service unavailable' }),\r\n      });\r\n    });\r\n    \r\n    await navigateToEmails(page);\r\n    \r\n    const firstEmail = page.locator('[data-testid=\"email-item\"], .email-item').first();\r\n    await firstEmail.click();\r\n    \r\n    const classifyButton = page.locator(\r\n      'button:has-text(\"Classify\"), button:has-text(\"Process\")'\r\n    ).first();\r\n    \r\n    if (await classifyButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await classifyButton.click();\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify error message is displayed\r\n      const hasError = await page.locator(\r\n        'text=/error|failed|unavailable/i, [role=\"alert\"], .error, .alert-danger'\r\n      ).count();\r\n      expect(hasError).toBeGreaterThan(0);\r\n    }\r\n  });\r\n  \r\n  test('error path: should handle empty email list', async ({ page, mockEmailAPI }) => {\r\n    // Mock empty email list\r\n    await mockEmailAPI(page, []);\r\n    \r\n    await page.goto('/emails');\r\n    await page.waitForLoadState('networkidle');\r\n    \r\n    // Verify empty state message\r\n    const emptyState = await page.locator(\r\n      'text=/no emails|empty|no messages/i, [data-testid=\"empty-state\"]'\r\n    ).count();\r\n    expect(emptyState).toBeGreaterThan(0);\r\n  });\r\n});\r\n\r\ntest.describe('Critical User Flow 2: Task Creation and Management', () => {\r\n  test('happy path: should create task from email, update it, and mark complete', async ({ \r\n    page, \r\n    mockEmails, \r\n    mockTasks,\r\n    mockEmailAPI, \r\n    mockTaskAPI,\r\n    navigateToEmails \r\n  }) => {\r\n    await mockEmailAPI(page, mockEmails);\r\n    await mockTaskAPI(page, mockTasks);\r\n    \r\n    // Start at emails page\r\n    await navigateToEmails(page);\r\n    \r\n    // Select an email\r\n    const firstEmail = page.locator('[data-testid=\"email-item\"], .email-item').first();\r\n    await firstEmail.click();\r\n    await page.waitForTimeout(1000);\r\n    \r\n    // Look for create task button\r\n    const createTaskButton = page.locator(\r\n      'button:has-text(\"Create Task\"), button:has-text(\"Add Task\"), button:has-text(\"Task\")'\r\n    ).first();\r\n    \r\n    if (await createTaskButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      // Track task creation API call\r\n      const createPromise = page.waitForResponse(resp => \r\n        resp.url().includes('/api/tasks') && \r\n        resp.request().method() === 'POST' &&\r\n        resp.status() === 201\r\n      );\r\n      \r\n      await createTaskButton.click();\r\n      await page.waitForTimeout(1000);\r\n      \r\n      // Fill task form if modal appears\r\n      const titleInput = page.locator('input[name=\"title\"], input[placeholder*=\"title\" i]').first();\r\n      if (await titleInput.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await titleInput.fill('E2E Test Task: Complete report');\r\n        \r\n        const descInput = page.locator('textarea[name=\"description\"], textarea[placeholder*=\"description\" i]').first();\r\n        if (await descInput.isVisible().catch(() => false)) {\r\n          await descInput.fill('This is a test task created during E2E testing');\r\n        }\r\n        \r\n        // Submit form\r\n        const submitButton = page.locator('button:has-text(\"Create\"), button:has-text(\"Save\"), button[type=\"submit\"]').first();\r\n        await submitButton.click();\r\n        \r\n        // Verify task was created\r\n        const response = await createPromise;\r\n        const taskData = await response.json();\r\n        expect(taskData.id).toBeDefined();\r\n        expect(taskData.title).toContain('Complete report');\r\n      }\r\n      \r\n      // Navigate to tasks page\r\n      await page.goto('/tasks');\r\n      await page.waitForLoadState('networkidle');\r\n      \r\n      // Verify task appears in list\r\n      const taskExists = await page.locator('text=/Complete report|E2E Test Task/i').count();\r\n      expect(taskExists).toBeGreaterThan(0);\r\n      \r\n      // Update task status\r\n      const task = page.locator('text=/Complete report/i').first();\r\n      await task.click();\r\n      await page.waitForTimeout(500);\r\n      \r\n      // Change status to in_progress\r\n      const statusDropdown = page.locator('select[name=\"status\"], [role=\"combobox\"]:has-text(\"Status\")').first();\r\n      if (await statusDropdown.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await statusDropdown.selectOption('in_progress');\r\n        await page.waitForTimeout(1000);\r\n        \r\n        // Verify status updated\r\n        const hasInProgress = await page.locator('text=/in progress|in_progress/i').count();\r\n        expect(hasInProgress).toBeGreaterThan(0);\r\n        \r\n        // Mark as complete\r\n        await statusDropdown.selectOption('completed');\r\n        await page.waitForTimeout(1000);\r\n        \r\n        // Verify completed status\r\n        const hasCompleted = await page.locator('text=/completed|done/i').count();\r\n        expect(hasCompleted).toBeGreaterThan(0);\r\n      }\r\n    }\r\n  });\r\n  \r\n  test('error path: should handle task creation failure', async ({ \r\n    page, \r\n    mockEmails, \r\n    mockEmailAPI \r\n  }) => {\r\n    await mockEmailAPI(page, mockEmails);\r\n    \r\n    // Mock task creation failure\r\n    await page.route('**/api/tasks', async (route) => {\r\n      if (route.request().method() === 'POST') {\r\n        await route.fulfill({\r\n          status: 400,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ error: 'Invalid task data' }),\r\n        });\r\n      } else {\r\n        await route.continue();\r\n      }\r\n    });\r\n    \r\n    await page.goto('/emails');\r\n    await page.waitForLoadState('networkidle');\r\n    \r\n    const firstEmail = page.locator('[data-testid=\"email-item\"], .email-item').first();\r\n    await firstEmail.click();\r\n    \r\n    const createTaskButton = page.locator('button:has-text(\"Create Task\"), button:has-text(\"Add Task\")').first();\r\n    \r\n    if (await createTaskButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await createTaskButton.click();\r\n      await page.waitForTimeout(1000);\r\n      \r\n      const titleInput = page.locator('input[name=\"title\"], input[placeholder*=\"title\" i]').first();\r\n      if (await titleInput.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await titleInput.fill('Test Task');\r\n        \r\n        const submitButton = page.locator('button:has-text(\"Create\"), button:has-text(\"Save\")').first();\r\n        await submitButton.click();\r\n        await page.waitForTimeout(2000);\r\n        \r\n        // Verify error is displayed\r\n        const hasError = await page.locator('text=/error|failed|invalid/i, [role=\"alert\"]').count();\r\n        expect(hasError).toBeGreaterThan(0);\r\n      }\r\n    }\r\n  });\r\n});\r\n\r\ntest.describe('Critical User Flow 3: Bulk Processing and Category Review', () => {\r\n  test('happy path: should bulk process emails, review categories, and edit classification', async ({ \r\n    page, \r\n    mockEmails, \r\n    mockEmailAPI, \r\n    mockAIAPI \r\n  }) => {\r\n    await mockEmailAPI(page, mockEmails);\r\n    await mockAIAPI(page);\r\n    \r\n    await page.goto('/emails');\r\n    await page.waitForLoadState('networkidle');\r\n    \r\n    // Select multiple emails\r\n    const selectAllCheckbox = page.locator('input[type=\"checkbox\"][aria-label*=\"select all\" i], input[type=\"checkbox\"].select-all').first();\r\n    \r\n    if (await selectAllCheckbox.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await selectAllCheckbox.check();\r\n      await page.waitForTimeout(500);\r\n      \r\n      // Verify emails are selected\r\n      const selectedCount = await page.locator('input[type=\"checkbox\"]:checked').count();\r\n      expect(selectedCount).toBeGreaterThan(1);\r\n      \r\n      // Trigger bulk processing\r\n      const bulkProcessButton = page.locator(\r\n        'button:has-text(\"Process Selected\"), button:has-text(\"Bulk Process\"), button:has-text(\"Classify Selected\")'\r\n      ).first();\r\n      \r\n      if (await bulkProcessButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n        // Track batch processing API call\r\n        const batchPromise = page.waitForResponse(resp => \r\n          resp.url().includes('/batch') && resp.status() === 200\r\n        );\r\n        \r\n        await bulkProcessButton.click();\r\n        await page.waitForTimeout(3000);\r\n        \r\n        // Verify batch processing completed\r\n        const response = await batchPromise;\r\n        const data = await response.json();\r\n        expect(data.processed || data.success).toBeDefined();\r\n        \r\n        // Review categories - look for category badges or labels\r\n        const categories = await page.locator('[class*=\"category\"], [class*=\"badge\"], [data-category]').count();\r\n        expect(categories).toBeGreaterThan(0);\r\n        \r\n        // Edit a classification\r\n        const firstEmail = page.locator('[data-testid=\"email-item\"], .email-item').first();\r\n        await firstEmail.click();\r\n        await page.waitForTimeout(500);\r\n        \r\n        // Look for category dropdown or edit button\r\n        const editButton = page.locator(\r\n          'button:has-text(\"Edit Category\"), button:has-text(\"Change Category\"), [data-testid=\"edit-category\"]'\r\n        ).first();\r\n        \r\n        if (await editButton.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n          await editButton.click();\r\n          await page.waitForTimeout(500);\r\n          \r\n          // Select different category\r\n          const categoryOption = page.locator('text=/optional_fyi|team_discussion/i').first();\r\n          if (await categoryOption.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n            await categoryOption.click();\r\n            await page.waitForTimeout(1000);\r\n            \r\n            // Verify category was updated\r\n            const updatedCategory = await page.locator('[class*=\"category\"]').first().textContent();\r\n            expect(updatedCategory).toBeTruthy();\r\n          }\r\n        }\r\n      }\r\n    }\r\n  });\r\n  \r\n  test('error path: should handle bulk processing partial failures', async ({ \r\n    page, \r\n    mockEmails, \r\n    mockEmailAPI \r\n  }) => {\r\n    await mockEmailAPI(page, mockEmails);\r\n    \r\n    // Mock partial batch failure\r\n    await page.route('**/api/processing/process-batch*', async (route) => {\r\n      const data = await route.request().postDataJSON();\r\n      const emailIds = data.email_ids || [];\r\n      \r\n      await route.fulfill({\r\n        status: 200,\r\n        contentType: 'application/json',\r\n        body: JSON.stringify({\r\n          processed: Math.floor(emailIds.length / 2),\r\n          failed: Math.ceil(emailIds.length / 2),\r\n          results: emailIds.map((id: string, idx: number) => ({\r\n            email_id: id,\r\n            success: idx % 2 === 0,\r\n            error: idx % 2 === 1 ? 'Processing failed' : undefined,\r\n          })),\r\n        }),\r\n      });\r\n    });\r\n    \r\n    await page.goto('/emails');\r\n    await page.waitForLoadState('networkidle');\r\n    \r\n    const selectAllCheckbox = page.locator('input[type=\"checkbox\"][aria-label*=\"select all\" i]').first();\r\n    \r\n    if (await selectAllCheckbox.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await selectAllCheckbox.check();\r\n      \r\n      const bulkProcessButton = page.locator('button:has-text(\"Process Selected\"), button:has-text(\"Bulk\")').first();\r\n      \r\n      if (await bulkProcessButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n        await bulkProcessButton.click();\r\n        await page.waitForTimeout(3000);\r\n        \r\n        // Verify partial failure notification\r\n        const hasWarning = await page.locator('text=/some failed|partially|warning/i, [role=\"alert\"]').count();\r\n        expect(hasWarning).toBeGreaterThan(0);\r\n      }\r\n    }\r\n  });\r\n});\r\n\r\ntest.describe('Critical User Flow 4: Settings Configuration', () => {\r\n  test('happy path: should update settings and verify changes applied', async ({ page }) => {\r\n    // Mock settings API\r\n    let savedSettings: any = {\r\n      username: 'Test User',\r\n      theme: 'light',\r\n      emailsPerPage: 20,\r\n      autoClassify: false,\r\n    };\r\n    \r\n    await page.route('**/api/settings*', async (route) => {\r\n      if (route.request().method() === 'GET') {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify(savedSettings),\r\n        });\r\n      } else if (route.request().method() === 'PUT' || route.request().method() === 'PATCH') {\r\n        const updates = await route.request().postDataJSON();\r\n        savedSettings = { ...savedSettings, ...updates };\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify(savedSettings),\r\n        });\r\n      } else {\r\n        await route.continue();\r\n      }\r\n    });\r\n    \r\n    // Navigate to settings\r\n    await page.goto('/settings');\r\n    await page.waitForLoadState('networkidle');\r\n    \r\n    // Wait for settings to load\r\n    await page.waitForTimeout(2000);\r\n    \r\n    // Update username\r\n    const usernameInput = page.locator('input[name=\"username\"], input[id=\"username\"], input[placeholder*=\"name\" i]').first();\r\n    if (await usernameInput.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await usernameInput.clear();\r\n      await usernameInput.fill('E2E Test User Updated');\r\n      \r\n      // Save settings\r\n      const saveButton = page.locator('button:has-text(\"Save\"), button:has-text(\"Update\"), button[type=\"submit\"]').first();\r\n      await saveButton.click();\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify save success message\r\n      const hasSuccess = await page.locator('text=/saved|success|updated/i, [role=\"alert\"]').count();\r\n      expect(hasSuccess).toBeGreaterThan(0);\r\n      \r\n      // Verify setting was persisted\r\n      expect(savedSettings.username).toBe('E2E Test User Updated');\r\n      \r\n      // Reload page to verify persistence\r\n      await page.reload();\r\n      await page.waitForTimeout(2000);\r\n      \r\n      const reloadedValue = await usernameInput.inputValue();\r\n      expect(reloadedValue).toBe('E2E Test User Updated');\r\n    }\r\n    \r\n    // Toggle auto-classify setting\r\n    const autoClassifyToggle = page.locator('input[type=\"checkbox\"][name*=\"auto\" i], input[type=\"checkbox\"][id*=\"auto\" i]').first();\r\n    if (await autoClassifyToggle.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n      const initialState = await autoClassifyToggle.isChecked();\r\n      await autoClassifyToggle.click();\r\n      await page.waitForTimeout(500);\r\n      \r\n      const saveButton = page.locator('button:has-text(\"Save\"), button:has-text(\"Update\")').first();\r\n      await saveButton.click();\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify setting was toggled\r\n      expect(savedSettings.autoClassify).toBe(!initialState);\r\n    }\r\n  });\r\n  \r\n  test('error path: should handle settings save failure', async ({ page }) => {\r\n    // Mock settings load success but save failure\r\n    await page.route('**/api/settings*', async (route) => {\r\n      if (route.request().method() === 'GET') {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ username: 'Test User' }),\r\n        });\r\n      } else if (route.request().method() === 'PUT' || route.request().method() === 'PATCH') {\r\n        await route.fulfill({\r\n          status: 500,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ error: 'Database connection failed' }),\r\n        });\r\n      } else {\r\n        await route.continue();\r\n      }\r\n    });\r\n    \r\n    await page.goto('/settings');\r\n    await page.waitForLoadState('networkidle');\r\n    await page.waitForTimeout(2000);\r\n    \r\n    const usernameInput = page.locator('input[name=\"username\"], input[id=\"username\"]').first();\r\n    if (await usernameInput.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await usernameInput.clear();\r\n      await usernameInput.fill('Should Fail');\r\n      \r\n      const saveButton = page.locator('button:has-text(\"Save\"), button:has-text(\"Update\")').first();\r\n      await saveButton.click();\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify error message\r\n      const hasError = await page.locator('text=/error|failed|unable/i, [role=\"alert\"], .error').count();\r\n      expect(hasError).toBeGreaterThan(0);\r\n    }\r\n  });\r\n});\r\n\r\ntest.describe('Critical User Flow 5: Error Recovery and Retry', () => {\r\n  test('should handle network timeout and retry successfully', async ({ \r\n    page, \r\n    mockEmails, \r\n    mockEmailAPI \r\n  }) => {\r\n    let attemptCount = 0;\r\n    \r\n    // First attempt fails, second succeeds\r\n    await page.route('**/api/emails*', async (route) => {\r\n      attemptCount++;\r\n      \r\n      if (attemptCount === 1) {\r\n        // Simulate timeout on first attempt\r\n        await new Promise(resolve => setTimeout(resolve, 100));\r\n        await route.abort('timedout');\r\n      } else {\r\n        // Success on retry\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({\r\n            emails: mockEmails.slice(0, 10),\r\n            total: mockEmails.length,\r\n            page: 1,\r\n            per_page: 20,\r\n            total_pages: 1,\r\n          }),\r\n        });\r\n      }\r\n    });\r\n    \r\n    await page.goto('/emails');\r\n    \r\n    // Wait for retry attempt\r\n    await page.waitForTimeout(5000);\r\n    \r\n    // Verify retry button or automatic retry succeeded\r\n    const retryButton = page.locator('button:has-text(\"Retry\"), button:has-text(\"Try Again\")').first();\r\n    \r\n    if (await retryButton.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n      await retryButton.click();\r\n      await page.waitForTimeout(3000);\r\n    }\r\n    \r\n    // Verify emails eventually load after retry\r\n    const emailCount = await page.locator('[data-testid=\"email-item\"], .email-item').count();\r\n    expect(emailCount).toBeGreaterThan(0);\r\n    expect(attemptCount).toBeGreaterThanOrEqual(2);\r\n  });\r\n  \r\n  test('should recover from 500 server error with manual retry', async ({ page }) => {\r\n    let attemptCount = 0;\r\n    \r\n    await page.route('**/api/emails*', async (route) => {\r\n      attemptCount++;\r\n      \r\n      if (attemptCount === 1) {\r\n        await route.fulfill({\r\n          status: 500,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ error: 'Internal server error' }),\r\n        });\r\n      } else {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({\r\n            emails: [],\r\n            total: 0,\r\n            page: 1,\r\n            per_page: 20,\r\n            total_pages: 0,\r\n          }),\r\n        });\r\n      }\r\n    });\r\n    \r\n    await page.goto('/emails');\r\n    await page.waitForTimeout(2000);\r\n    \r\n    // Verify error is displayed\r\n    const hasError = await page.locator('text=/error|failed|500/i, [role=\"alert\"]').count();\r\n    expect(hasError).toBeGreaterThan(0);\r\n    \r\n    // Click retry button\r\n    const retryButton = page.locator('button:has-text(\"Retry\"), button:has-text(\"Try Again\"), button:has-text(\"Reload\")').first();\r\n    \r\n    if (await retryButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await retryButton.click();\r\n      await page.waitForTimeout(3000);\r\n      \r\n      // Verify error is cleared and request succeeded\r\n      const errorStillVisible = await page.locator('[role=\"alert\"]:has-text(\"error\")').count();\r\n      expect(errorStillVisible).toBe(0);\r\n      expect(attemptCount).toBe(2);\r\n    }\r\n  });\r\n  \r\n  test('should handle 404 not found error gracefully', async ({ page }) => {\r\n    await page.route('**/api/emails/invalid-id*', async (route) => {\r\n      await route.fulfill({\r\n        status: 404,\r\n        contentType: 'application/json',\r\n        body: JSON.stringify({ error: 'Email not found' }),\r\n      });\r\n    });\r\n    \r\n    // Try to navigate to non-existent email\r\n    await page.goto('/emails/invalid-id');\r\n    await page.waitForTimeout(2000);\r\n    \r\n    // Verify 404 error handling\r\n    const has404Message = await page.locator('text=/not found|404|doesn\\'t exist/i').count();\r\n    expect(has404Message).toBeGreaterThan(0);\r\n    \r\n    // Verify back button or link to email list\r\n    const backButton = page.locator('button:has-text(\"Back\"), a:has-text(\"Back to\"), a:has-text(\"Email List\")').first();\r\n    \r\n    if (await backButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await backButton.click();\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify we're back at a valid page\r\n      const url = page.url();\r\n      expect(url).toMatch(/\\/emails\\/?$/);\r\n    }\r\n  });\r\n  \r\n  test('should recover from failed AI classification with retry', async ({ \r\n    page, \r\n    mockEmails, \r\n    mockEmailAPI \r\n  }) => {\r\n    await mockEmailAPI(page, mockEmails);\r\n    \r\n    let classifyAttempts = 0;\r\n    \r\n    await page.route('**/api/ai/classify*', async (route) => {\r\n      classifyAttempts++;\r\n      \r\n      if (classifyAttempts === 1) {\r\n        await route.fulfill({\r\n          status: 503,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({ error: 'AI service temporarily unavailable' }),\r\n        });\r\n      } else {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify({\r\n            category: 'required_personal_action',\r\n            confidence: 0.92,\r\n            reasoning: 'Action required based on content analysis',\r\n          }),\r\n        });\r\n      }\r\n    });\r\n    \r\n    await page.goto('/emails');\r\n    await page.waitForLoadState('networkidle');\r\n    \r\n    // Select and classify email\r\n    const firstEmail = page.locator('[data-testid=\"email-item\"], .email-item').first();\r\n    await firstEmail.click();\r\n    \r\n    const classifyButton = page.locator('button:has-text(\"Classify\"), button:has-text(\"Process\")').first();\r\n    \r\n    if (await classifyButton.isVisible({ timeout: 5000 }).catch(() => false)) {\r\n      await classifyButton.click();\r\n      await page.waitForTimeout(2000);\r\n      \r\n      // Verify error is shown\r\n      const hasError = await page.locator('text=/unavailable|error|failed/i').count();\r\n      expect(hasError).toBeGreaterThan(0);\r\n      \r\n      // Retry classification\r\n      const retryButton = page.locator('button:has-text(\"Retry\"), button:has-text(\"Try Again\")').first();\r\n      \r\n      if (await retryButton.isVisible({ timeout: 3000 }).catch(() => false)) {\r\n        await retryButton.click();\r\n      } else {\r\n        // If no retry button, click classify again\r\n        await classifyButton.click();\r\n      }\r\n      \r\n      await page.waitForTimeout(3000);\r\n      \r\n      // Verify classification succeeded on retry\r\n      const hasCategory = await page.locator('text=/required_personal_action|category/i').count();\r\n      expect(hasCategory).toBeGreaterThan(0);\r\n      expect(classifyAttempts).toBe(2);\r\n    }\r\n  });\r\n});\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\electron\\dashboard.electron.spec.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":22,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'e' is defined but never used.","line":67,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":67,"endColumn":13},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":91,"column":57,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":91,"endColumn":58,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2862,2863],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2862,2862],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":91,"column":77,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":91,"endColumn":78,"suggestions":[{"messageId":"removeEscape","fix":{"range":[2882,2883],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[2882,2882],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":127,"column":59,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":127,"endColumn":60,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4032,4033],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4032,4032],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":127,"column":79,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":127,"endColumn":80,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4052,4053],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4052,4052],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":143,"column":57,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":143,"endColumn":58,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4579,4580],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4579,4579],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\\".","line":143,"column":75,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":143,"endColumn":76,"suggestions":[{"messageId":"removeEscape","fix":{"range":[4597,4598],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[4597,4597],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":8,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Electron Dashboard Tests\n * Tests button clicks, navigation, and core functionality in the Electron app\n */\nimport { test, expect, _electron as electron, ElectronApplication, Page } from '@playwright/test';\nimport * as path from 'path';\nimport { existsSync } from 'fs';\nimport { fileURLToPath } from 'url';\n\nconst __filename = fileURLToPath(import.meta.url);\nconst __dirname = path.dirname(__filename);\n\nlet electronApp: ElectronApplication;\nlet page: Page;\n\ntest.beforeAll(async () => {\n  // Kill any existing processes\n  try {\n    await import('child_process').then(cp => {\n      cp.execSync('Get-Process -Name electron,python -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue', { shell: 'pwsh.exe', stdio: 'ignore' });\n    });\n  } catch (e) {\n    // Ignore errors\n  }\n\n  // Wait for cleanup\n  await new Promise(resolve => setTimeout(resolve, 2000));\n\n  // Launch Electron\n  const electronPath = path.join(__dirname, '../../../..', 'electron');\n  const electronExecutable = path.join(\n    electronPath,\n    'node_modules',\n    '.bin',\n    process.platform === 'win32' ? 'electron.cmd' : 'electron',\n  );\n\n  if (!existsSync(electronExecutable)) {\n    throw new Error(`Electron executable not found at ${electronExecutable}`);\n  }\n\n  electronApp = await electron.launch({\n    executablePath: electronExecutable,\n    args: [path.join(electronPath, 'main.js')],\n    cwd: electronPath,\n    timeout: 45000,\n  });\n\n  // Wait for window\n  page = await electronApp.firstWindow({ timeout: 30000 });\n  await page.waitForLoadState('domcontentloaded', { timeout: 30000 });\n  \n  // Give extra time for backend to start\n  await page.waitForTimeout(5000);\n});\n\ntest.afterAll(async () => {\n  if (electronApp) {\n    await electronApp.close();\n  }\n  \n  // Cleanup processes\n  try {\n    await import('child_process').then(cp => {\n      cp.execSync('Get-Process -Name electron,python -ErrorAction SilentlyContinue | Stop-Process -Force -ErrorAction SilentlyContinue', { shell: 'pwsh.exe', stdio: 'ignore' });\n    });\n  } catch (e) {\n    // Ignore errors\n  }\n});\n\ntest.describe('Dashboard Functionality', () => {\n  test('should load dashboard page', async () => {\n    await expect(page.locator('h1')).toContainText('Dashboard', { timeout: 10000 });\n  });\n\n  test('should display stat cards', async () => {\n    const statCards = page.locator('.stat-card');\n    await expect(statCards).toHaveCount(2, { timeout: 10000 });\n  });\n\n  test('should display quick action buttons', async () => {\n    const quickActions = page.locator('.quick-actions');\n    await expect(quickActions).toBeVisible({ timeout: 10000 });\n    \n    const buttons = page.locator('.quick-actions button');\n    await expect(buttons).toHaveCount(3);\n  });\n\n  test('Process Emails button should be clickable', async () => {\n    const processButton = page.locator('button:has-text(\\\"Process New Emails\\\")');\n    \n    // Check visibility and enabled state\n    await expect(processButton).toBeVisible({ timeout: 10000 });\n    await expect(processButton).toBeEnabled();\n    \n    // Get computed style to verify clickability\n    const computedStyle = await processButton.evaluate((el) => {\n      const style = window.getComputedStyle(el);\n      return {\n        pointerEvents: style.pointerEvents,\n        cursor: style.cursor,\n        zIndex: style.zIndex,\n      };\n    });\n    \n    console.log('Process button style:', computedStyle);\n    expect(computedStyle.cursor).toContain('pointer');\n    \n    // Try to click\n    let dialogShown = false;\n    page.once('dialog', async dialog => {\n      dialogShown = true;\n      console.log('Dialog message:', dialog.message());\n      expect(dialog.message()).toContain('Processing emails');\n      await dialog.accept();\n    });\n    \n    await processButton.click({ timeout: 5000 });\n    \n    // Wait a bit for dialog\n    await page.waitForTimeout(1000);\n    expect(dialogShown).toBe(true);\n  });\n\n  test('View Tasks button should navigate', async () => {\n    const viewTasksButton = page.locator('button:has-text(\\\"View Pending Tasks\\\")');\n    \n    await expect(viewTasksButton).toBeVisible({ timeout: 10000 });\n    await expect(viewTasksButton).toBeEnabled();\n    \n    await viewTasksButton.click({ timeout: 5000 });\n    \n    // Should navigate to tasks page\n    await expect(page).toHaveURL(/.*tasks/, { timeout: 10000 });\n    \n    // Navigate back\n    await page.goBack();\n    await page.waitForLoadState('domcontentloaded');\n  });\n\n  test('Generate Summary button should be clickable', async () => {\n    const summaryButton = page.locator('button:has-text(\\\"Generate Summary\\\")');\n    \n    await expect(summaryButton).toBeVisible({ timeout: 10000 });\n    await expect(summaryButton).toBeEnabled();\n    \n    let dialogShown = false;\n    page.once('dialog', async dialog => {\n      dialogShown = true;\n      console.log('Dialog message:', dialog.message());\n      expect(dialog.message()).toContain('Generating summary');\n      await dialog.accept();\n    });\n    \n    await summaryButton.click({ timeout: 5000 });\n    \n    await page.waitForTimeout(1000);\n    expect(dialogShown).toBe(true);\n  });\n\n  test('Backend API should be accessible', async () => {\n    // Test if backend is responding\n    const response = await page.evaluate(async () => {\n      try {\n        const res = await fetch('http://localhost:8000/health');\n        return {\n          ok: res.ok,\n          status: res.status,\n          data: await res.json(),\n        };\n      } catch (error) {\n        return {\n          ok: false,\n          error: String(error),\n        };\n      }\n    });\n    \n    console.log('Backend health check:', response);\n    expect(response.ok).toBe(true);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\email-editing.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'assertElementCount' is defined but never used.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\email-list-reload.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\email-processing.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockEmails' is defined but never used.","line":64,"column":59,"nodeType":null,"messageId":"unusedVar","endLine":64,"endColumn":69,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\enhanced-assertions-example.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\fixtures\\test-helpers.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":212,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5562,5565],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5562,5565],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":272,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":272,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7090,7093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7090,7093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":292,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7583,7586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7583,7586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":400,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":400,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10424,10427],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10424,10427],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":409,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10643,10646],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10643,10646],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":631,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":631,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17234,17237],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17234,17237],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'optionalFields' is assigned a value but never used.","line":633,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":633,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":672,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":672,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18406,18409],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18406,18409],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":673,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":673,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18449,18452],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18449,18452],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":2,"message":"Unexpected any. Specify a different type.","line":765,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":765,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21067,21070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21067,21070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":10,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * Test Helper Utilities\r\n * \r\n * Provides reusable utilities for E2E tests including:\r\n * - Robust wait strategies\r\n * - Element existence assertions\r\n * - Data validation helpers\r\n */\r\n\r\nimport { Page, Locator, expect } from '@playwright/test';\r\n\r\n/**\r\n * Wait for an element with retry logic and clear error messages\r\n * Fails loudly if element is not found\r\n */\r\nexport async function waitForElement(\r\n  page: Page,\r\n  selector: string,\r\n  options: {\r\n    timeout?: number;\r\n    state?: 'attached' | 'visible' | 'hidden';\r\n    errorMessage?: string;\r\n  } = {}\r\n): Promise<Locator> {\r\n  const { timeout = 10000, state = 'visible', errorMessage } = options;\r\n  \r\n  const locator = page.locator(selector);\r\n  \r\n  try {\r\n    await locator.waitFor({ state, timeout });\r\n    return locator;\r\n  } catch (error) {\r\n    const customMessage = errorMessage || `Element not found: ${selector}`;\r\n    throw new Error(`${customMessage}\\n\\nPage URL: ${page.url()}\\nOriginal error: ${error}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Wait for multiple elements to be visible\r\n * Returns all matching locators\r\n */\r\nexport async function waitForElements(\r\n  page: Page,\r\n  selector: string,\r\n  options: {\r\n    timeout?: number;\r\n    minCount?: number;\r\n  } = {}\r\n): Promise<Locator[]> {\r\n  const { timeout = 10000, minCount = 1 } = options;\r\n  \r\n  const locator = page.locator(selector);\r\n  \r\n  await expect(locator).toHaveCount(minCount, { timeout }).catch(() => {\r\n    throw new Error(\r\n      `Expected at least ${minCount} elements matching \"${selector}\", but found none.\\n` +\r\n      `Page URL: ${page.url()}`\r\n    );\r\n  });\r\n  \r\n  return locator.all();\r\n}\r\n\r\n/**\r\n * Wait for element with specific text content\r\n */\r\nexport async function waitForElementWithText(\r\n  page: Page,\r\n  selector: string,\r\n  text: string | RegExp,\r\n  options: { timeout?: number } = {}\r\n): Promise<Locator> {\r\n  const { timeout = 10000 } = options;\r\n  \r\n  const locator = page.locator(selector).filter({ hasText: text });\r\n  \r\n  await locator.waitFor({ state: 'visible', timeout }).catch(() => {\r\n    throw new Error(\r\n      `Element matching \"${selector}\" with text \"${text}\" not found.\\n` +\r\n      `Page URL: ${page.url()}`\r\n    );\r\n  });\r\n  \r\n  return locator;\r\n}\r\n\r\n/**\r\n * Wait for element by data-testid attribute\r\n */\r\nexport async function waitForTestId(\r\n  page: Page,\r\n  testId: string,\r\n  options: { timeout?: number; state?: 'attached' | 'visible' | 'hidden' } = {}\r\n): Promise<Locator> {\r\n  const { timeout = 10000, state = 'visible' } = options;\r\n  \r\n  const locator = page.getByTestId(testId);\r\n  \r\n  await locator.waitFor({ state, timeout }).catch(() => {\r\n    throw new Error(\r\n      `Element with data-testid=\"${testId}\" not found.\\n` +\r\n      `Page URL: ${page.url()}`\r\n    );\r\n  });\r\n  \r\n  return locator;\r\n}\r\n\r\n/**\r\n * Click element with retry logic for transient failures\r\n */\r\nexport async function clickElement(\r\n  locator: Locator,\r\n  options: {\r\n    retries?: number;\r\n    delay?: number;\r\n  } = {}\r\n): Promise<void> {\r\n  const { retries = 3, delay = 500 } = options;\r\n  \r\n  for (let attempt = 1; attempt <= retries; attempt++) {\r\n    try {\r\n      await locator.click({ timeout: 5000 });\r\n      return;\r\n    } catch (error) {\r\n      if (attempt === retries) {\r\n        throw new Error(`Failed to click element after ${retries} attempts: ${error}`);\r\n      }\r\n      await new Promise(resolve => setTimeout(resolve, delay));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Select option from dropdown with validation\r\n */\r\nexport async function selectOption(\r\n  locator: Locator,\r\n  value: string,\r\n  options: { retries?: number } = {}\r\n): Promise<void> {\r\n  const { retries = 3 } = options;\r\n  \r\n  for (let attempt = 1; attempt <= retries; attempt++) {\r\n    try {\r\n      await locator.selectOption(value, { timeout: 5000 });\r\n      \r\n      // Verify selection\r\n      const selectedValue = await locator.inputValue();\r\n      if (selectedValue === value) {\r\n        return;\r\n      }\r\n      \r\n      throw new Error(`Selected value \"${selectedValue}\" does not match expected \"${value}\"`);\r\n    } catch (error) {\r\n      if (attempt === retries) {\r\n        throw new Error(`Failed to select option \"${value}\" after ${retries} attempts: ${error}`);\r\n      }\r\n      await new Promise(resolve => setTimeout(resolve, 500));\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Assert element exists and is visible\r\n */\r\nexport async function assertElementExists(\r\n  page: Page,\r\n  selector: string,\r\n  errorMessage?: string\r\n): Promise<void> {\r\n  const locator = page.locator(selector);\r\n  const count = await locator.count();\r\n  \r\n  if (count === 0) {\r\n    const message = errorMessage || `Expected element \"${selector}\" to exist, but it was not found.`;\r\n    throw new Error(`${message}\\nPage URL: ${page.url()}`);\r\n  }\r\n  \r\n  await expect(locator.first()).toBeVisible();\r\n}\r\n\r\n/**\r\n * Assert specific count of elements\r\n */\r\nexport async function assertElementCount(\r\n  page: Page,\r\n  selector: string,\r\n  expectedCount: number,\r\n  errorMessage?: string\r\n): Promise<void> {\r\n  const locator = page.locator(selector);\r\n  const actualCount = await locator.count();\r\n  \r\n  if (actualCount !== expectedCount) {\r\n    const message = errorMessage || \r\n      `Expected ${expectedCount} elements matching \"${selector}\", but found ${actualCount}.`;\r\n    throw new Error(`${message}\\nPage URL: ${page.url()}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Wait for API response with specific criteria\r\n */\r\nexport async function waitForAPIResponse(\r\n  page: Page,\r\n  urlPattern: string | RegExp,\r\n  options: {\r\n    timeout?: number;\r\n    status?: number;\r\n  } = {}\r\n): Promise<any> {\r\n  const { timeout = 10000, status = 200 } = options;\r\n  \r\n  const response = await page.waitForResponse(\r\n    (resp) => {\r\n      const url = resp.url();\r\n      const matchesPattern = typeof urlPattern === 'string' \r\n        ? url.includes(urlPattern)\r\n        : urlPattern.test(url);\r\n      return matchesPattern && resp.status() === status;\r\n    },\r\n    { timeout }\r\n  ).catch(() => {\r\n    throw new Error(\r\n      `API response matching \"${urlPattern}\" with status ${status} not received within ${timeout}ms.\\n` +\r\n      `Page URL: ${page.url()}`\r\n    );\r\n  });\r\n  \r\n  return response.json();\r\n}\r\n\r\n/**\r\n * Wait for element to have specific attribute value\r\n */\r\nexport async function waitForAttribute(\r\n  locator: Locator,\r\n  attribute: string,\r\n  expectedValue: string | RegExp,\r\n  options: { timeout?: number } = {}\r\n): Promise<void> {\r\n  const { timeout = 10000 } = options;\r\n  \r\n  await expect(locator).toHaveAttribute(attribute, expectedValue, { timeout });\r\n}\r\n\r\n/**\r\n * Check if element exists without failing\r\n * Returns true if element exists and is visible\r\n */\r\nexport async function elementExists(\r\n  page: Page,\r\n  selector: string,\r\n  timeout: number = 2000\r\n): Promise<boolean> {\r\n  try {\r\n    const locator = page.locator(selector);\r\n    await locator.waitFor({ state: 'visible', timeout });\r\n    return true;\r\n  } catch {\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Verify localStorage contains expected data\r\n */\r\nexport async function assertLocalStorage(\r\n  page: Page,\r\n  key: string,\r\n  expectedValue?: any\r\n): Promise<void> {\r\n  const value = await page.evaluate((k) => localStorage.getItem(k), key);\r\n  \r\n  if (value === null) {\r\n    throw new Error(`localStorage key \"${key}\" not found`);\r\n  }\r\n  \r\n  if (expectedValue !== undefined) {\r\n    const parsedValue = JSON.parse(value);\r\n    expect(parsedValue).toEqual(expectedValue);\r\n  }\r\n}\r\n\r\n/**\r\n * Verify sessionStorage contains expected data\r\n */\r\nexport async function assertSessionStorage(\r\n  page: Page,\r\n  key: string,\r\n  expectedValue?: any\r\n): Promise<void> {\r\n  const value = await page.evaluate((k) => sessionStorage.getItem(k), key);\r\n  \r\n  if (value === null) {\r\n    throw new Error(`sessionStorage key \"${key}\" not found`);\r\n  }\r\n  \r\n  if (expectedValue !== undefined) {\r\n    const parsedValue = JSON.parse(value);\r\n    expect(parsedValue).toEqual(expectedValue);\r\n  }\r\n}\r\n\r\n/**\r\n * Wait for loading state to complete\r\n */\r\nexport async function waitForLoadingComplete(\r\n  page: Page,\r\n  options: {\r\n    timeout?: number;\r\n    loadingSelector?: string;\r\n  } = {}\r\n): Promise<void> {\r\n  const { timeout = 10000, loadingSelector = '[data-testid=\"loading\"], .loading, .spinner' } = options;\r\n  \r\n  // Wait for loading indicator to appear and then disappear\r\n  const locator = page.locator(loadingSelector);\r\n  const isVisible = await locator.isVisible().catch(() => false);\r\n  \r\n  if (isVisible) {\r\n    await locator.waitFor({ state: 'hidden', timeout }).catch(() => {\r\n      throw new Error(`Loading indicator did not disappear within ${timeout}ms`);\r\n    });\r\n  }\r\n  \r\n  // Also wait for network to be idle\r\n  await page.waitForLoadState('networkidle', { timeout });\r\n}\r\n\r\n/**\r\n * Fill form field with validation\r\n */\r\nexport async function fillField(\r\n  locator: Locator,\r\n  value: string,\r\n  options: { pressEnter?: boolean } = {}\r\n): Promise<void> {\r\n  const { pressEnter = false } = options;\r\n  \r\n  await locator.clear();\r\n  await locator.fill(value);\r\n  \r\n  // Verify the value was set correctly\r\n  const actualValue = await locator.inputValue();\r\n  if (actualValue !== value) {\r\n    throw new Error(`Field value \"${actualValue}\" does not match expected \"${value}\"`);\r\n  }\r\n  \r\n  if (pressEnter) {\r\n    await locator.press('Enter');\r\n  }\r\n}\r\n\r\n/**\r\n * Assert toast/notification message appears\r\n */\r\nexport async function assertNotification(\r\n  page: Page,\r\n  message: string | RegExp,\r\n  options: { timeout?: number } = {}\r\n): Promise<void> {\r\n  const { timeout = 5000 } = options;\r\n  \r\n  const notificationSelectors = [\r\n    '[role=\"alert\"]',\r\n    '.toast',\r\n    '.notification',\r\n    '[data-testid=\"notification\"]',\r\n  ];\r\n  \r\n  let found = false;\r\n  for (const selector of notificationSelectors) {\r\n    const locator = page.locator(selector).filter({ hasText: message });\r\n    const count = await locator.count();\r\n    \r\n    if (count > 0) {\r\n      await expect(locator.first()).toBeVisible({ timeout });\r\n      found = true;\r\n      break;\r\n    }\r\n  }\r\n  \r\n  if (!found) {\r\n    throw new Error(\r\n      `Notification with message \"${message}\" not found.\\n` +\r\n      `Tried selectors: ${notificationSelectors.join(', ')}\\n` +\r\n      `Page URL: ${page.url()}`\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * Validate API request payload contains expected data\r\n */\r\nexport async function assertAPIPayload(\r\n  page: Page,\r\n  urlPattern: string | RegExp,\r\n  expectedPayload: Record<string, any>,\r\n  options: {\r\n    timeout?: number;\r\n    method?: string;\r\n    partial?: boolean;\r\n  } = {}\r\n): Promise<void> {\r\n  const { timeout = 10000, method = 'POST', partial = false } = options;\r\n\r\n  let capturedPayload: any = null;\r\n  let payloadFound = false;\r\n\r\n  const requestPromise = page.waitForRequest(\r\n    (request) => {\r\n      const url = request.url();\r\n      const matchesPattern = typeof urlPattern === 'string'\r\n        ? url.includes(urlPattern)\r\n        : urlPattern.test(url);\r\n      \r\n      if (matchesPattern && request.method() === method) {\r\n        try {\r\n          capturedPayload = request.postDataJSON();\r\n          payloadFound = true;\r\n          return true;\r\n        } catch {\r\n          return false;\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n    { timeout }\r\n  );\r\n\r\n  await requestPromise.catch(() => {\r\n    throw new Error(\r\n      `API request to \"${urlPattern}\" with method ${method} not captured within ${timeout}ms.\\n` +\r\n      `Page URL: ${page.url()}`\r\n    );\r\n  });\r\n\r\n  if (!payloadFound || !capturedPayload) {\r\n    throw new Error(`No payload captured for API request to \"${urlPattern}\"`);\r\n  }\r\n\r\n  if (partial) {\r\n    for (const [key, value] of Object.entries(expectedPayload)) {\r\n      expect(capturedPayload).toHaveProperty(key, value);\r\n    }\r\n  } else {\r\n    expect(capturedPayload).toMatchObject(expectedPayload);\r\n  }\r\n}\r\n\r\n/**\r\n * Validate email data accuracy in UI\r\n */\r\nexport async function assertEmailData(\r\n  page: Page,\r\n  emailData: {\r\n    subject?: string | RegExp;\r\n    sender?: string | RegExp;\r\n    body?: string | RegExp;\r\n    category?: string;\r\n    count?: number;\r\n  }\r\n): Promise<void> {\r\n  const { subject, sender, body, category, count } = emailData;\r\n\r\n  if (count !== undefined) {\r\n    const emailItems = page.locator('[data-testid=\"email-item\"], .email-item');\r\n    const actualCount = await emailItems.count();\r\n    if (actualCount !== count) {\r\n      throw new Error(\r\n        `Expected ${count} emails, but found ${actualCount}.\\n` +\r\n        `Page URL: ${page.url()}`\r\n      );\r\n    }\r\n  }\r\n\r\n  if (subject) {\r\n    const subjectLocator = page.locator('[data-testid=\"email-subject\"], .email-subject, .subject')\r\n      .filter({ hasText: subject });\r\n    await expect(subjectLocator.first()).toBeVisible({ timeout: 5000 });\r\n  }\r\n\r\n  if (sender) {\r\n    const senderLocator = page.locator('[data-testid=\"email-sender\"], .email-sender, .sender, .from')\r\n      .filter({ hasText: sender });\r\n    await expect(senderLocator.first()).toBeVisible({ timeout: 5000 });\r\n  }\r\n\r\n  if (body) {\r\n    const bodyLocator = page.locator('[data-testid=\"email-body\"], .email-body, .body, .content')\r\n      .filter({ hasText: body });\r\n    await expect(bodyLocator.first()).toBeVisible({ timeout: 5000 });\r\n  }\r\n\r\n  if (category) {\r\n    const categoryLocator = page.locator(\r\n      `[data-testid=\"email-category\"], .category, [data-category=\"${category}\"]`\r\n    ).filter({ hasText: new RegExp(category, 'i') });\r\n    await expect(categoryLocator.first()).toBeVisible({ timeout: 5000 });\r\n  }\r\n}\r\n\r\n/**\r\n * Validate task data accuracy in UI\r\n */\r\nexport async function assertTaskData(\r\n  page: Page,\r\n  taskData: {\r\n    title?: string | RegExp;\r\n    description?: string | RegExp;\r\n    status?: string;\r\n    priority?: string;\r\n    count?: number;\r\n  }\r\n): Promise<void> {\r\n  const { title, description, status, priority, count } = taskData;\r\n\r\n  if (count !== undefined) {\r\n    const taskCards = page.locator('[data-testid=\"task-card\"], .task-card');\r\n    const actualCount = await taskCards.count();\r\n    if (actualCount !== count) {\r\n      throw new Error(\r\n        `Expected ${count} tasks, but found ${actualCount}.\\n` +\r\n        `Page URL: ${page.url()}`\r\n      );\r\n    }\r\n  }\r\n\r\n  if (title) {\r\n    const titleLocator = page.locator('[data-testid=\"task-title\"], .task-title')\r\n      .filter({ hasText: title });\r\n    await expect(titleLocator.first()).toBeVisible({ timeout: 5000 });\r\n  }\r\n\r\n  if (description) {\r\n    const descLocator = page.locator('[data-testid=\"task-description\"], .task-description')\r\n      .filter({ hasText: description });\r\n    await expect(descLocator.first()).toBeVisible({ timeout: 5000 });\r\n  }\r\n\r\n  if (status) {\r\n    const statusLocator = page.locator(`[data-task-status=\"${status}\"], [data-testid=\"task-status\"]`)\r\n      .filter({ hasText: new RegExp(status, 'i') });\r\n    await expect(statusLocator.first()).toBeVisible({ timeout: 5000 });\r\n  }\r\n\r\n  if (priority) {\r\n    const priorityLocator = page.locator(`[data-task-priority=\"${priority}\"], [data-testid=\"task-priority\"]`)\r\n      .filter({ hasText: new RegExp(priority, 'i') });\r\n    await expect(priorityLocator.first()).toBeVisible({ timeout: 5000 });\r\n  }\r\n}\r\n\r\n/**\r\n * Validate error message content and type\r\n */\r\nexport async function assertErrorMessage(\r\n  page: Page,\r\n  expectedError: {\r\n    message: string | RegExp;\r\n    type?: 'error' | 'warning' | 'info';\r\n    contains?: string[];\r\n  },\r\n  options: { timeout?: number } = {}\r\n): Promise<void> {\r\n  const { timeout = 5000 } = options;\r\n  const { message, type, contains } = expectedError;\r\n\r\n  const errorSelectors = [\r\n    '[role=\"alert\"]',\r\n    '.error',\r\n    '.error-message',\r\n    '.alert-danger',\r\n    '[data-testid=\"error-message\"]',\r\n  ];\r\n\r\n  if (type === 'warning') {\r\n    errorSelectors.push('.warning', '.alert-warning', '[data-testid=\"warning\"]');\r\n  } else if (type === 'info') {\r\n    errorSelectors.push('.info', '.alert-info', '[data-testid=\"info\"]');\r\n  }\r\n\r\n  let errorElement: Locator | null = null;\r\n  for (const selector of errorSelectors) {\r\n    const locator = page.locator(selector).filter({ hasText: message });\r\n    const count = await locator.count();\r\n    if (count > 0) {\r\n      errorElement = locator.first();\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (!errorElement) {\r\n    throw new Error(\r\n      `Error message matching \"${message}\" not found.\\n` +\r\n      `Tried selectors: ${errorSelectors.join(', ')}\\n` +\r\n      `Page URL: ${page.url()}`\r\n    );\r\n  }\r\n\r\n  await expect(errorElement).toBeVisible({ timeout });\r\n\r\n  if (contains && contains.length > 0) {\r\n    const errorText = await errorElement.textContent();\r\n    for (const keyword of contains) {\r\n      if (!errorText?.toLowerCase().includes(keyword.toLowerCase())) {\r\n        throw new Error(\r\n          `Error message does not contain expected keyword \"${keyword}\".\\n` +\r\n          `Actual message: \"${errorText}\"\\n` +\r\n          `Page URL: ${page.url()}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Validate API response data structure\r\n */\r\nexport async function assertAPIResponseStructure(\r\n  page: Page,\r\n  urlPattern: string | RegExp,\r\n  expectedStructure: {\r\n    requiredFields: string[];\r\n    optionalFields?: string[];\r\n    statusCode?: number;\r\n  },\r\n  options: { timeout?: number } = {}\r\n): Promise<any> {\r\n  const { timeout = 10000 } = options;\r\n  const { requiredFields, optionalFields, statusCode = 200 } = expectedStructure;\r\n\r\n  const response = await page.waitForResponse(\r\n    (resp) => {\r\n      const url = resp.url();\r\n      const matchesPattern = typeof urlPattern === 'string'\r\n        ? url.includes(urlPattern)\r\n        : urlPattern.test(url);\r\n      return matchesPattern && resp.status() === statusCode;\r\n    },\r\n    { timeout }\r\n  ).catch(() => {\r\n    throw new Error(\r\n      `API response matching \"${urlPattern}\" with status ${statusCode} not received within ${timeout}ms.\\n` +\r\n      `Page URL: ${page.url()}`\r\n    );\r\n  });\r\n\r\n  const data = await response.json();\r\n\r\n  for (const field of requiredFields) {\r\n    if (!(field in data)) {\r\n      throw new Error(\r\n        `Required field \"${field}\" missing from API response.\\n` +\r\n        `Response data: ${JSON.stringify(data, null, 2)}\\n` +\r\n        `API URL: ${response.url()}`\r\n      );\r\n    }\r\n  }\r\n\r\n  return data;\r\n}\r\n\r\n/**\r\n * Validate state persistence across page reloads\r\n */\r\nexport async function assertStatePersistence(\r\n  page: Page,\r\n  stateChecks: {\r\n    localStorage?: Record<string, any>;\r\n    sessionStorage?: Record<string, any>;\r\n    urlParams?: Record<string, string>;\r\n  }\r\n): Promise<void> {\r\n  const { localStorage: localStorageChecks, sessionStorage: sessionStorageChecks, urlParams } = stateChecks;\r\n\r\n  if (localStorageChecks) {\r\n    for (const [key, expectedValue] of Object.entries(localStorageChecks)) {\r\n      await assertLocalStorage(page, key, expectedValue);\r\n    }\r\n  }\r\n\r\n  if (sessionStorageChecks) {\r\n    for (const [key, expectedValue] of Object.entries(sessionStorageChecks)) {\r\n      await assertSessionStorage(page, key, expectedValue);\r\n    }\r\n  }\r\n\r\n  if (urlParams) {\r\n    const currentUrl = new URL(page.url());\r\n    for (const [param, expectedValue] of Object.entries(urlParams)) {\r\n      const actualValue = currentUrl.searchParams.get(param);\r\n      if (actualValue !== expectedValue) {\r\n        throw new Error(\r\n          `URL parameter \"${param}\" has value \"${actualValue}\", expected \"${expectedValue}\".\\n` +\r\n          `Page URL: ${page.url()}`\r\n        );\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Validate accessibility attributes\r\n */\r\nexport async function assertAccessibility(\r\n  locator: Locator,\r\n  checks: {\r\n    role?: string;\r\n    ariaLabel?: string | RegExp;\r\n    ariaDescribedBy?: boolean;\r\n    tabIndex?: number;\r\n    hasAltText?: boolean;\r\n  }\r\n): Promise<void> {\r\n  const { role, ariaLabel, ariaDescribedBy, tabIndex, hasAltText } = checks;\r\n\r\n  if (role) {\r\n    await expect(locator).toHaveAttribute('role', role);\r\n  }\r\n\r\n  if (ariaLabel) {\r\n    await expect(locator).toHaveAttribute('aria-label', ariaLabel);\r\n  }\r\n\r\n  if (ariaDescribedBy) {\r\n    const describedBy = await locator.getAttribute('aria-describedby');\r\n    if (!describedBy) {\r\n      throw new Error('Element missing aria-describedby attribute');\r\n    }\r\n  }\r\n\r\n  if (tabIndex !== undefined) {\r\n    await expect(locator).toHaveAttribute('tabindex', String(tabIndex));\r\n  }\r\n\r\n  if (hasAltText) {\r\n    const tagName = await locator.evaluate((el) => el.tagName.toLowerCase());\r\n    if (tagName === 'img') {\r\n      const alt = await locator.getAttribute('alt');\r\n      if (!alt || alt.trim() === '') {\r\n        throw new Error('Image element missing alt text');\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Capture and validate API call sequence\r\n */\r\nexport async function assertAPICallSequence(\r\n  page: Page,\r\n  expectedSequence: Array<{\r\n    urlPattern: string | RegExp;\r\n    method: string;\r\n    order: number;\r\n  }>,\r\n  options: { timeout?: number } = {}\r\n): Promise<void> {\r\n  const { timeout = 15000 } = options;\r\n  const capturedCalls: Array<{ url: string; method: string; timestamp: number }> = [];\r\n\r\n  const requestHandler = (request: any) => {\r\n    for (const expected of expectedSequence) {\r\n      const url = request.url();\r\n      const matchesPattern = typeof expected.urlPattern === 'string'\r\n        ? url.includes(expected.urlPattern)\r\n        : expected.urlPattern.test(url);\r\n      \r\n      if (matchesPattern && request.method() === expected.method) {\r\n        capturedCalls.push({\r\n          url,\r\n          method: request.method(),\r\n          timestamp: Date.now(),\r\n        });\r\n      }\r\n    }\r\n  };\r\n\r\n  page.on('request', requestHandler);\r\n\r\n  await page.waitForTimeout(timeout);\r\n\r\n  page.off('request', requestHandler);\r\n\r\n  if (capturedCalls.length < expectedSequence.length) {\r\n    throw new Error(\r\n      `Expected ${expectedSequence.length} API calls, but captured only ${capturedCalls.length}.\\n` +\r\n      `Captured: ${JSON.stringify(capturedCalls, null, 2)}\\n` +\r\n      `Expected: ${JSON.stringify(expectedSequence, null, 2)}`\r\n    );\r\n  }\r\n\r\n  for (let i = 0; i < expectedSequence.length - 1; i++) {\r\n    if (capturedCalls[i].timestamp > capturedCalls[i + 1].timestamp) {\r\n      throw new Error(\r\n        `API calls not in expected order.\\n` +\r\n        `Call ${i} (${capturedCalls[i].method} ${capturedCalls[i].url}) ` +\r\n        `happened after Call ${i + 1} (${capturedCalls[i + 1].method} ${capturedCalls[i + 1].url})`\r\n      );\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Validate form validation behavior\r\n */\r\nexport async function assertFormValidation(\r\n  page: Page,\r\n  formSelector: string,\r\n  validationTests: Array<{\r\n    field: string;\r\n    invalidValue: string;\r\n    expectedError: string | RegExp;\r\n  }>\r\n): Promise<void> {\r\n  const form = page.locator(formSelector);\r\n  await expect(form).toBeVisible();\r\n\r\n  for (const test of validationTests) {\r\n    const fieldLocator = form.locator(`[name=\"${test.field}\"], #${test.field}`);\r\n    await fieldLocator.clear();\r\n    await fieldLocator.fill(test.invalidValue);\r\n    await fieldLocator.blur();\r\n\r\n    await page.waitForTimeout(500);\r\n\r\n    const errorLocator = page.locator(\r\n      `[id=\"${test.field}-error\"], [data-error-for=\"${test.field}\"], .error, .invalid-feedback`\r\n    ).filter({ hasText: test.expectedError });\r\n\r\n    await expect(errorLocator).toBeVisible({ timeout: 3000 });\r\n  }\r\n}\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\fixtures\\test-setup.ts","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-unused-vars').","line":3,"column":1,"severity":1,"nodeType":null,"fix":{"range":[88,142],"text":" "}}],"suppressedMessages":[{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"authenticatedPage\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":435,"column":11,"nodeType":"Identifier","endLine":435,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":438,"column":22,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":438,"endColumn":25,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"mockEmails\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":439,"column":11,"nodeType":"Identifier","endLine":439,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":442,"column":21,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":442,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"mockTasks\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":443,"column":11,"nodeType":"Identifier","endLine":443,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":446,"column":24,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":446,"endColumn":27,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"mockEmailAPI\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":447,"column":11,"nodeType":"Identifier","endLine":447,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":450,"column":23,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":450,"endColumn":26,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"mockTaskAPI\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":451,"column":11,"nodeType":"Identifier","endLine":451,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":454,"column":21,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":454,"endColumn":24,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"mockAIAPI\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":455,"column":11,"nodeType":"Identifier","endLine":455,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":458,"column":28,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":458,"endColumn":31,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"navigateToEmails\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":459,"column":11,"nodeType":"Identifier","endLine":459,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":462,"column":27,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":462,"endColumn":30,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"navigateToTasks\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":463,"column":11,"nodeType":"Identifier","endLine":463,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"no-empty-pattern","severity":2,"message":"Unexpected empty object pattern.","line":466,"column":32,"nodeType":"ObjectPattern","messageId":"unexpected","endLine":466,"endColumn":35,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"use\" is called in function \"navigateToProcessing\" that is neither a React function component nor a custom React Hook function. React component names must start with an uppercase letter. React Hook names must start with the word \"use\".","line":467,"column":11,"nodeType":"Identifier","endLine":467,"endColumn":14,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":1,"source":"/* eslint-disable react-hooks/rules-of-hooks */\r\n/* eslint-disable no-empty-pattern */\r\n/* eslint-disable @typescript-eslint/no-unused-vars */\r\nimport { test as base, expect, Page } from '@playwright/test';\r\n\r\n/**\r\n * Mock email data for testing\r\n */\r\nexport interface MockEmail {\r\n  id: string;\r\n  subject: string;\r\n  sender: string;\r\n  recipient: string;\r\n  body: string;\r\n  received_time: string;\r\n  is_read: boolean;\r\n  categories: string[];\r\n  conversation_id: string;\r\n  category?: string;\r\n}\r\n\r\n/**\r\n * Mock task data for testing\r\n */\r\nexport interface MockTask {\r\n  id: string;\r\n  title: string;\r\n  description: string;\r\n  status: 'pending' | 'in_progress' | 'completed' | 'cancelled';\r\n  priority: 'low' | 'medium' | 'high';\r\n  due_date?: string;\r\n  created_at: string;\r\n  email_id?: string;\r\n}\r\n\r\n/**\r\n * Test fixtures with common setup and utilities\r\n */\r\ninterface TestFixtures {\r\n  // Authenticated page with token\r\n  authenticatedPage: Page;\r\n  \r\n  // Mock email data\r\n  mockEmails: MockEmail[];\r\n  \r\n  // Mock task data\r\n  mockTasks: MockTask[];\r\n  \r\n  // API mocking utilities\r\n  mockEmailAPI: (page: Page, emails: MockEmail[]) => Promise<void>;\r\n  mockTaskAPI: (page: Page, tasks: MockTask[]) => Promise<void>;\r\n  mockAIAPI: (page: Page) => Promise<void>;\r\n  \r\n  // Navigation helpers\r\n  navigateToEmails: (page: Page) => Promise<void>;\r\n  navigateToTasks: (page: Page) => Promise<void>;\r\n  navigateToProcessing: (page: Page) => Promise<void>;\r\n}\r\n\r\n/**\r\n * Generate mock email data\r\n */\r\nexport function generateMockEmails(count: number = 10): MockEmail[] {\r\n  const categories = ['required_personal_action', 'optional_fyi', 'team_discussion', 'task_delegation'];\r\n  const emails: MockEmail[] = [];\r\n  \r\n  for (let i = 1; i <= count; i++) {\r\n    emails.push({\r\n      id: `email-${i}`,\r\n      subject: `Test Email ${i}: ${i % 2 === 0 ? 'Action Required' : 'FYI Update'}`,\r\n      sender: `sender${i}@example.com`,\r\n      recipient: 'user@example.com',\r\n      body: `This is the body of test email ${i}. ${i % 2 === 0 ? 'Please take action.' : 'For your information only.'}`,\r\n      received_time: new Date(Date.now() - i * 3600000).toISOString(),\r\n      is_read: i > 5,\r\n      categories: i % 3 === 0 ? ['Important'] : [],\r\n      conversation_id: `conv-${Math.floor(i / 3)}`,\r\n      category: categories[i % categories.length],\r\n    });\r\n  }\r\n  \r\n  return emails;\r\n}\r\n\r\n/**\r\n * Generate mock task data\r\n */\r\nexport function generateMockTasks(count: number = 5): MockTask[] {\r\n  const tasks: MockTask[] = [];\r\n  const statuses: MockTask['status'][] = ['pending', 'in_progress', 'completed', 'cancelled'];\r\n  const priorities: MockTask['priority'][] = ['low', 'medium', 'high'];\r\n  \r\n  for (let i = 1; i <= count; i++) {\r\n    tasks.push({\r\n      id: `task-${i}`,\r\n      title: `Task ${i}: ${i % 2 === 0 ? 'Complete Report' : 'Review Document'}`,\r\n      description: `This is the description for task ${i}`,\r\n      status: statuses[i % statuses.length],\r\n      priority: priorities[i % priorities.length],\r\n      due_date: new Date(Date.now() + i * 86400000).toISOString(),\r\n      created_at: new Date(Date.now() - i * 3600000).toISOString(),\r\n      email_id: i <= 5 ? `email-${i}` : undefined,\r\n    });\r\n  }\r\n  \r\n  return tasks;\r\n}\r\n\r\n/**\r\n * Mock Email API responses\r\n */\r\nasync function mockEmailAPI(page: Page, emails: MockEmail[]): Promise<void> {\r\n  await page.route('**/api/emails*', async (route) => {\r\n    const url = new URL(route.request().url());\r\n    \r\n    // GET /api/emails - List emails with pagination\r\n    if (route.request().method() === 'GET' && url.pathname === '/api/emails') {\r\n      const page = parseInt(url.searchParams.get('page') || '1');\r\n      const perPage = parseInt(url.searchParams.get('per_page') || '20');\r\n      const start = (page - 1) * perPage;\r\n      const end = start + perPage;\r\n      \r\n      await route.fulfill({\r\n        status: 200,\r\n        contentType: 'application/json',\r\n        body: JSON.stringify({\r\n          emails: emails.slice(start, end),\r\n          total: emails.length,\r\n          page,\r\n          per_page: perPage,\r\n          total_pages: Math.ceil(emails.length / perPage),\r\n        }),\r\n      });\r\n    }\r\n    // GET /api/emails/:id - Get single email\r\n    else if (route.request().method() === 'GET' && url.pathname.match(/\\/api\\/emails\\/email-\\d+$/)) {\r\n      const id = url.pathname.split('/').pop();\r\n      const email = emails.find((e) => e.id === id);\r\n      \r\n      if (email) {\r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify(email),\r\n        });\r\n      } else {\r\n        await route.fulfill({ status: 404, body: 'Email not found' });\r\n      }\r\n    }\r\n    // PATCH /api/emails/:id - Update email\r\n    else if (route.request().method() === 'PATCH') {\r\n      const id = url.pathname.split('/').pop();\r\n      const email = emails.find((e) => e.id === id);\r\n      \r\n      if (email) {\r\n        const updates = await route.request().postDataJSON();\r\n        Object.assign(email, updates);\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify(email),\r\n        });\r\n      } else {\r\n        await route.fulfill({ status: 404, body: 'Email not found' });\r\n      }\r\n    }\r\n    // POST /api/emails/batch - Batch operations\r\n    else if (route.request().method() === 'POST' && url.pathname.includes('/batch')) {\r\n      await route.fulfill({\r\n        status: 200,\r\n        contentType: 'application/json',\r\n        body: JSON.stringify({ success: true, updated: 0 }),\r\n      });\r\n    }\r\n    else {\r\n      await route.continue();\r\n    }\r\n  });\r\n  \r\n  // Mock email stats\r\n  await page.route('**/api/emails/stats*', async (route) => {\r\n    await route.fulfill({\r\n      status: 200,\r\n      contentType: 'application/json',\r\n      body: JSON.stringify({\r\n        total: emails.length,\r\n        unread: emails.filter((e) => !e.is_read).length,\r\n        by_category: {\r\n          required_personal_action: emails.filter((e) => e.category === 'required_personal_action').length,\r\n          optional_fyi: emails.filter((e) => e.category === 'optional_fyi').length,\r\n          team_discussion: emails.filter((e) => e.category === 'team_discussion').length,\r\n          task_delegation: emails.filter((e) => e.category === 'task_delegation').length,\r\n        },\r\n      }),\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Mock Task API responses\r\n */\r\nasync function mockTaskAPI(page: Page, tasks: MockTask[]): Promise<void> {\r\n  await page.route('**/api/tasks*', async (route) => {\r\n    const url = new URL(route.request().url());\r\n    \r\n    // GET /api/tasks - List tasks\r\n    if (route.request().method() === 'GET' && url.pathname === '/api/tasks') {\r\n      await route.fulfill({\r\n        status: 200,\r\n        contentType: 'application/json',\r\n        body: JSON.stringify({\r\n          tasks,\r\n          total: tasks.length,\r\n          page: 1,\r\n          per_page: 50,\r\n          total_pages: 1,\r\n        }),\r\n      });\r\n    }\r\n    // POST /api/tasks - Create task\r\n    else if (route.request().method() === 'POST' && url.pathname === '/api/tasks') {\r\n      const taskData = await route.request().postDataJSON();\r\n      const newTask: MockTask = {\r\n        id: `task-${Date.now()}`,\r\n        created_at: new Date().toISOString(),\r\n        status: 'pending',\r\n        priority: 'medium',\r\n        ...taskData,\r\n      };\r\n      tasks.push(newTask);\r\n      \r\n      await route.fulfill({\r\n        status: 201,\r\n        contentType: 'application/json',\r\n        body: JSON.stringify(newTask),\r\n      });\r\n    }\r\n    // PATCH /api/tasks/:id - Update task\r\n    else if (route.request().method() === 'PATCH') {\r\n      const id = url.pathname.split('/').pop();\r\n      const task = tasks.find((t) => t.id === id);\r\n      \r\n      if (task) {\r\n        const updates = await route.request().postDataJSON();\r\n        Object.assign(task, updates);\r\n        \r\n        await route.fulfill({\r\n          status: 200,\r\n          contentType: 'application/json',\r\n          body: JSON.stringify(task),\r\n        });\r\n      } else {\r\n        await route.fulfill({ status: 404, body: 'Task not found' });\r\n      }\r\n    }\r\n    // DELETE /api/tasks/:id - Delete task\r\n    else if (route.request().method() === 'DELETE') {\r\n      const id = url.pathname.split('/').pop();\r\n      const index = tasks.findIndex((t) => t.id === id);\r\n      \r\n      if (index !== -1) {\r\n        tasks.splice(index, 1);\r\n        await route.fulfill({ status: 204 });\r\n      } else {\r\n        await route.fulfill({ status: 404, body: 'Task not found' });\r\n      }\r\n    }\r\n    else {\r\n      await route.continue();\r\n    }\r\n  });\r\n  \r\n  // Mock task stats\r\n  await page.route('**/api/tasks/stats*', async (route) => {\r\n    await route.fulfill({\r\n      status: 200,\r\n      contentType: 'application/json',\r\n      body: JSON.stringify({\r\n        total: tasks.length,\r\n        by_status: {\r\n          pending: tasks.filter((t) => t.status === 'pending').length,\r\n          in_progress: tasks.filter((t) => t.status === 'in_progress').length,\r\n          completed: tasks.filter((t) => t.status === 'completed').length,\r\n          cancelled: tasks.filter((t) => t.status === 'cancelled').length,\r\n        },\r\n        by_priority: {\r\n          low: tasks.filter((t) => t.priority === 'low').length,\r\n          medium: tasks.filter((t) => t.priority === 'medium').length,\r\n          high: tasks.filter((t) => t.priority === 'high').length,\r\n        },\r\n      }),\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Mock AI API responses\r\n */\r\nasync function mockAIAPI(page: Page): Promise<void> {\r\n  // Mock classification\r\n  await page.route('**/api/ai/classify*', async (route) => {\r\n    await route.fulfill({\r\n      status: 200,\r\n      contentType: 'application/json',\r\n      body: JSON.stringify({\r\n        category: 'required_personal_action',\r\n        confidence: 0.95,\r\n        reasoning: 'Email requires immediate action',\r\n        alternatives: ['task_delegation', 'team_discussion'],\r\n      }),\r\n    });\r\n  });\r\n  \r\n  // Mock action item extraction\r\n  await page.route('**/api/ai/extract-actions*', async (route) => {\r\n    await route.fulfill({\r\n      status: 200,\r\n      contentType: 'application/json',\r\n      body: JSON.stringify({\r\n        action_items: [\r\n          {\r\n            action: 'Complete project report',\r\n            deadline: '2024-12-31',\r\n            priority: 'high',\r\n          },\r\n          {\r\n            action: 'Schedule team meeting',\r\n            deadline: '2024-12-25',\r\n            priority: 'medium',\r\n          },\r\n        ],\r\n      }),\r\n    });\r\n  });\r\n  \r\n  // Mock summary generation\r\n  await page.route('**/api/ai/summarize*', async (route) => {\r\n    await route.fulfill({\r\n      status: 200,\r\n      contentType: 'application/json',\r\n      body: JSON.stringify({\r\n        summary: 'This email contains important action items that require immediate attention.',\r\n        key_points: ['Project deadline approaching', 'Team meeting needed', 'Report submission required'],\r\n      }),\r\n    });\r\n  });\r\n  \r\n  // Mock batch processing\r\n  await page.route('**/api/processing/process-batch*', async (route) => {\r\n    const data = await route.request().postDataJSON();\r\n    const emailIds = data.email_ids || [];\r\n    \r\n    await route.fulfill({\r\n      status: 200,\r\n      contentType: 'application/json',\r\n      body: JSON.stringify({\r\n        processed: emailIds.length,\r\n        failed: 0,\r\n        results: emailIds.map((id: string) => ({\r\n          email_id: id,\r\n          category: 'required_personal_action',\r\n          success: true,\r\n        })),\r\n      }),\r\n    });\r\n  });\r\n}\r\n\r\n/**\r\n * Navigation helper - go to emails page\r\n */\r\nasync function navigateToEmails(page: Page): Promise<void> {\r\n  await page.goto('/emails');\r\n  await page.waitForLoadState('networkidle');\r\n}\r\n\r\n/**\r\n * Navigation helper - go to tasks page\r\n */\r\nasync function navigateToTasks(page: Page): Promise<void> {\r\n  await page.goto('/tasks');\r\n  await page.waitForLoadState('networkidle');\r\n}\r\n\r\n/**\r\n * Navigation helper - go to processing page\r\n */\r\nasync function navigateToProcessing(page: Page): Promise<void> {\r\n  await page.goto('/processing');\r\n  await page.waitForLoadState('networkidle');\r\n}\r\n\r\n/**\r\n * Create authenticated page (skip login if not required)\r\n */\r\nasync function createAuthenticatedPage(page: Page): Promise<Page> {\r\n  // Mock health check\r\n  await page.route('**/health*', async (route) => {\r\n    await route.fulfill({\r\n      status: 200,\r\n      contentType: 'application/json',\r\n      body: JSON.stringify({\r\n        status: 'healthy',\r\n        service: 'email-helper-backend',\r\n        version: '1.0.0',\r\n        provider: 'com',\r\n      }),\r\n    });\r\n  });\r\n  \r\n  // For tests, we can skip authentication by mocking the auth check\r\n  // In real scenarios, you'd set up proper auth tokens\r\n  await page.route('**/auth/me*', async (route) => {\r\n    await route.fulfill({\r\n      status: 200,\r\n      contentType: 'application/json',\r\n      body: JSON.stringify({\r\n        id: 'test-user-1',\r\n        email: 'test@example.com',\r\n        name: 'Test User',\r\n      }),\r\n    });\r\n  });\r\n  \r\n  return page;\r\n}\r\n\r\n/**\r\n * Extended test fixture with utilities\r\n */\r\nexport const test = base.extend<TestFixtures>({\r\n  authenticatedPage: async ({ page }, use) => {\r\n    const authPage = await createAuthenticatedPage(page);\r\n    await use(authPage);\r\n  },\r\n  \r\n  mockEmails: async ({ }, use) => {\r\n    await use(generateMockEmails(15));\r\n  },\r\n  \r\n  mockTasks: async ({ }, use) => {\r\n    await use(generateMockTasks(8));\r\n  },\r\n  \r\n  mockEmailAPI: async ({ }, use) => {\r\n    await use(mockEmailAPI);\r\n  },\r\n  \r\n  mockTaskAPI: async ({ }, use) => {\r\n    await use(mockTaskAPI);\r\n  },\r\n  \r\n  mockAIAPI: async ({ }, use) => {\r\n    await use(mockAIAPI);\r\n  },\r\n  \r\n  navigateToEmails: async ({ }, use) => {\r\n    await use(navigateToEmails);\r\n  },\r\n  \r\n  navigateToTasks: async ({ }, use) => {\r\n    await use(navigateToTasks);\r\n  },\r\n  \r\n  navigateToProcessing: async ({ }, use) => {\r\n    await use(navigateToProcessing);\r\n  },\r\n});\r\n\r\nexport { expect };\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\settings-real.spec.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\summary-generation.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'waitForAPIResponse' is defined but never used.","line":17,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":17,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'assertElementExists' is defined but never used.","line":18,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":18,"endColumn":22,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'firstEmail' is assigned a value but never used.","line":59,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":59,"endColumn":21,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'page' is defined but never used.","line":131,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":131,"endColumn":58,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\tests\\e2e\\task-management.spec.ts","messages":[],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'firstTask' is assigned a value but never used.","line":81,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":81,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'firstTask' is assigned a value but never used.","line":90,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":90,"endColumn":20,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockTasks' is defined but never used.","line":110,"column":66,"nodeType":null,"messageId":"unusedVar","endLine":110,"endColumn":75,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'mockTasks' is defined but never used.","line":119,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":73,"suppressions":[{"kind":"directive","justification":""}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":2,"message":"'page' is defined but never used.","line":170,"column":59,"nodeType":null,"messageId":"unusedVar","endLine":170,"endColumn":63,"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\vite.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\ameliapayne\\email_helper\\frontend\\vitest.config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
